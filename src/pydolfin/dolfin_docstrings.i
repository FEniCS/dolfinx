// An autogenerated docstringfile


// File: index.xml

// File: classdolfin_1_1Array.xml
%feature("docstring") dolfin::Array "

Array is a container that provides O(1) access time to elements and
O(1) memory overhead.

It is a wrapper for std::vector, so see the STL manual for further
details:http://www.sgi.com/tech/stl/

C++ includes: Array.h ";

%feature("docstring")  dolfin::Array::Array "

Create empty array. ";

%feature("docstring")  dolfin::Array::Array "

Create array of given size. ";

%feature("docstring")  dolfin::Array::Array "

Create array containing two elements. ";

%feature("docstring")  dolfin::Array::Array "

Create array containing three elements. ";

%feature("docstring")  dolfin::Array::Array "

Create array containing four elements. ";

%feature("docstring")  dolfin::Array::Array "

Create array containing five elements. ";

%feature("docstring")  dolfin::Array::Array "

Copy constructor. ";

%feature("docstring")  dolfin::Array::~Array "

Destructor. ";


// File: classdolfin_1_1Assembler.xml
%feature("docstring") dolfin::Assembler "

This class provides automated assembly of linear systems, or more
generally, assembly of a sparse tensor from a given variational form.

C++ includes: Assembler.h ";

%feature("docstring")  dolfin::Assembler::Assembler "

Constructor. ";

%feature("docstring")  dolfin::Assembler::~Assembler "

Destructor. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble tensor from given variational form. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble tensor from given variational form over a sub domain. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble tensor from given variational form over sub domains. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble scalar from given variational form. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble scalar from given variational form over a sub domain. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble scalar from given variational form over sub domains. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble tensor from given (UFC) form, coefficients and sub domains.
This is the main assembly function in DOLFIN. All other assembly
functions end up calling this function.

The MeshFunction arguments can be used to specify assembly over
subdomains of the mesh cells, exterior facets and interior facets.
Either a null pointer or an empty MeshFunction may be used to specify
that the tensor should be assembled over the entire set of cells or
facets. ";


// File: classdolfin_1_1AvgMeshSize.xml
%feature("docstring") dolfin::AvgMeshSize "

This function represents the average of the local mesh size on a given
mesh.

C++ includes: SpecialFunctions.h ";

%feature("docstring")  dolfin::AvgMeshSize::AvgMeshSize "";

%feature("docstring")  dolfin::AvgMeshSize::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";


// File: classdolfin_1_1BoundaryCondition.xml
%feature("docstring") dolfin::BoundaryCondition "

Common base class for boundary conditions.

C++ includes: BoundaryCondition.h ";

%feature("docstring")  dolfin::BoundaryCondition::BoundaryCondition "

Constructor. ";

%feature("docstring")  dolfin::BoundaryCondition::~BoundaryCondition "

Destructor. ";

%feature("docstring")  dolfin::BoundaryCondition::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::BoundaryCondition::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::BoundaryCondition::apply "

Apply boundary condition to linear system for a nonlinear problem. ";

%feature("docstring")  dolfin::BoundaryCondition::apply "

Apply boundary condition to linear system for a nonlinear problem. ";


// File: classdolfin_1_1BoundaryCondition_1_1LocalData.xml


// File: classdolfin_1_1BoundaryMesh.xml
%feature("docstring") dolfin::BoundaryMesh "

A BoundaryMesh is a mesh over the boundary of some given mesh.

C++ includes: BoundaryMesh.h ";

%feature("docstring")  dolfin::BoundaryMesh::BoundaryMesh "

Create an empty boundary mesh. ";

%feature("docstring")  dolfin::BoundaryMesh::BoundaryMesh "

Create boundary mesh from given mesh. ";

%feature("docstring")  dolfin::BoundaryMesh::BoundaryMesh "

Create boundary mesh from given mesh and compute a pair of mappings
from the vertices and cells of the boundary to the corresponding mesh
entities in the original mesh ";

%feature("docstring")  dolfin::BoundaryMesh::~BoundaryMesh "

Destructor. ";

%feature("docstring")  dolfin::BoundaryMesh::init "

Initialize boundary mesh from given mesh. ";

%feature("docstring")  dolfin::BoundaryMesh::init "

Initialize boundary mesh from given mesh, including a pair of mappings
from the vertices and cells of the boundary to the corresponding mesh
entities in the original mesh ";


// File: classdolfin_1_1Cell.xml
%feature("docstring") dolfin::Cell "

A Cell is a MeshEntity of topological codimension 0.

C++ includes: Cell.h ";

%feature("docstring")  dolfin::Cell::Cell "

Constructor. ";

%feature("docstring")  dolfin::Cell::~Cell "

Destructor. ";

%feature("docstring")  dolfin::Cell::type "

Return type of cell. ";

%feature("docstring")  dolfin::Cell::orientation "

Compute orientation of cell (0 is right, 1 is left). ";

%feature("docstring")  dolfin::Cell::volume "

Compute (generalized) volume of cell. ";

%feature("docstring")  dolfin::Cell::diameter "

Compute diameter of cell. ";

%feature("docstring")  dolfin::Cell::midpoint "

Compute midpoint of cell. ";

%feature("docstring")  dolfin::Cell::normal "

Compute component i of normal of given facet with respect to the cell.
";


// File: classdolfin_1_1CellIterator.xml
%feature("docstring") dolfin::CellIterator "

A CellIterator is a MeshEntityIterator of topological codimension 0.

C++ includes: Cell.h ";

%feature("docstring")  dolfin::CellIterator::CellIterator "";

%feature("docstring")  dolfin::CellIterator::CellIterator "";


// File: classdolfin_1_1cGqMethod.xml
%feature("docstring") dolfin::cGqMethod "

Contains all numeric constants, such as nodal points and nodal
weights, needed for the cG(q) method. The order q must be at least 1.
Note that q refers to the polynomial order and not the order of
convergence for the method, which is 2q.

C++ includes: cGqMethod.h ";

%feature("docstring")  dolfin::cGqMethod::cGqMethod "";

%feature("docstring")  dolfin::cGqMethod::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::cGqMethod::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::cGqMethod::ueval "

Evaluate solution at given node (inline optimized). ";

%feature("docstring")  dolfin::cGqMethod::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::cGqMethod::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::cGqMethod::timestep "

Compute new time step based on the given residual. ";

%feature("docstring")  dolfin::cGqMethod::error "

Compute error estimate (modulo stability factor). ";

%feature("docstring")  dolfin::cGqMethod::disp "

Display method data. ";


// File: classdolfin_1_1ComplexODE.xml
%feature("docstring") dolfin::ComplexODE "

A ComplexODE represents an initial value problem for a system of
complex-valued ordinary differential equations:

M(z, t) z'(t) = f(z(t), t) on (0,T]

z(0) = z0,

where z(t) is a complex-valued vector of length n. The imaginary unit
is provided by the member variable j satisfying j^2 = -1.

This class is a wrapper for a standard real-valued ODE, and provides
an interface that automatically translates the given complex-valued
ODE of size n to a standard real-valued ODE of size N = 2n.

The real and imaginary parts of the solution are stored in the
following order in the solution vector u(t):

u = (Re z0, Im z0, Re z1, Im z1, ..., Re z_n-1, Im z_n-1).

C++ includes: ComplexODE.h ";

%feature("docstring")  dolfin::ComplexODE::ComplexODE "

Constructor. ";

%feature("docstring")  dolfin::ComplexODE::~ComplexODE "

Destructor. ";

%feature("docstring")  dolfin::ComplexODE::z0 "

Set initial values. ";

%feature("docstring")  dolfin::ComplexODE::f "

Evaluate right-hand side (multi-adaptive version). ";

%feature("docstring")  dolfin::ComplexODE::f "

Evaluate right-hand side (mono-adaptive version). ";

%feature("docstring")  dolfin::ComplexODE::M "

Compute product y = Mx for implicit system. ";

%feature("docstring")  dolfin::ComplexODE::J "

Compute product y = Jx for Jacobian J. ";

%feature("docstring")  dolfin::ComplexODE::k "

Return time step for component i (optional). ";

%feature("docstring")  dolfin::ComplexODE::update "

Update ODE, return false to stop (optional). ";

%feature("docstring")  dolfin::ComplexODE::u0 "

Return initial value for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::f "

Return right-hand side for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::f "

Evaluate right-hand side for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::M "

Compute product y = Mx for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::J "

Compute product y = Jx for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::timestep "

Return time step for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::update "

Update for real-valued ODE. ";


// File: classdolfin_1_1dGqMethod.xml
%feature("docstring") dolfin::dGqMethod "

Contains all numeric constants, such as nodal points and nodal
weights, needed for the dG(q) method. The order q must be at least 0.
Note that q refers to the polynomial order and not the order of
convergence for the method, which is 2q + 1.

C++ includes: dGqMethod.h ";

%feature("docstring")  dolfin::dGqMethod::dGqMethod "";

%feature("docstring")  dolfin::dGqMethod::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::dGqMethod::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::dGqMethod::ueval "

Evaluate solution at given node (inline optimized). ";

%feature("docstring")  dolfin::dGqMethod::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::dGqMethod::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::dGqMethod::timestep "

Compute new time step based on the given residual. ";

%feature("docstring")  dolfin::dGqMethod::error "

Compute error estimate (modulo stability factor). ";

%feature("docstring")  dolfin::dGqMethod::disp "

Display method data. ";


// File: classdolfin_1_1DirectedClique.xml
%feature("docstring") dolfin::DirectedClique "

A directed graph where all vertices are adjacent to each other. The
number of vertices is given by num_vertices >= 1. The number of edges
is given by (num_vertices - 1) * num_vertices)

C++ includes: DirectedClique.h ";

%feature("docstring")  dolfin::DirectedClique::DirectedClique "";


// File: classdolfin_1_1DirichletBC.xml
%feature("docstring") dolfin::DirichletBC "

This class specifies the interface for setting (strong) Dirichlet
boundary conditions for partial differential equations,

u = g on G,

where u is the solution to be computed, g is a function and G is a sub
domain of the mesh.

A DirichletBC is specified by a Function, a Mesh, a MeshFunction<uint>
over the facets of the mesh and an integer sub_domain specifying the
sub domain on which the boundary condition is to be applied.

For mixed systems (vector-valued and mixed elements), an optional set
of parameters may be used to specify for which sub system the boundary
condition should be specified.

C++ includes: DirichletBC.h ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create boundary condition for sub domain. ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create boundary condition for sub domain specified by index. ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create sub system boundary condition for sub domain. ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create sub system boundary condition for sub domain specified by
index. ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Simple creation of boundary condition with given value on the entire
boundary. ";

%feature("docstring")  dolfin::DirichletBC::~DirichletBC "

Destructor. ";

%feature("docstring")  dolfin::DirichletBC::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::DirichletBC::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::DirichletBC::apply "

Apply boundary condition to linear system for a nonlinear problem. ";

%feature("docstring")  dolfin::DirichletBC::apply "

Apply boundary condition to linear system for a nonlinear problem. ";

%feature("docstring")  dolfin::DirichletBC::mesh "

Return mesh. ";


// File: classdolfin_1_1DofMap.xml
%feature("docstring") dolfin::DofMap "

This class handles the mapping of degrees of freedom. It wraps a
ufc::dof_map on a specific mesh and provides optional precomputation
and reordering of dofs.

C++ includes: DofMap.h ";

%feature("docstring")  dolfin::DofMap::DofMap "

Create dof map on mesh. ";

%feature("docstring")  dolfin::DofMap::DofMap "

Create dof map on mesh (parallel). ";

%feature("docstring")  dolfin::DofMap::DofMap "

Create dof map on mesh. ";

%feature("docstring")  dolfin::DofMap::DofMap "

Create dof map on mesh (parallel). ";

%feature("docstring")  dolfin::DofMap::~DofMap "

Destructor. ";

%feature("docstring")  dolfin::DofMap::signature "

Return a string identifying the dof map. ";

%feature("docstring")  dolfin::DofMap::global_dimension "

Return the dimension of the global finite element function space. ";

%feature("docstring")  dolfin::DofMap::local_dimension "

Return the dimension of the local finite element function space. ";

%feature("docstring")  dolfin::DofMap::macro_local_dimension "

Return the dimension of the local finite element function space. ";

%feature("docstring")  dolfin::DofMap::num_facet_dofs "

Return number of facet dofs. ";

%feature("docstring")  dolfin::DofMap::tabulate_dofs "

Tabulate the local-to-global mapping of dofs on a cell. ";

%feature("docstring")  dolfin::DofMap::tabulate_facet_dofs "

Tabulate local-local facet dofs. ";

%feature("docstring")  dolfin::DofMap::tabulate_dofs "

Tabulate the local-to-global mapping of dofs on a ufc cell. ";

%feature("docstring")  dolfin::DofMap::tabulate_coordinates "";

%feature("docstring")  dolfin::DofMap::extractDofMap "

Extract sub dof map. ";

%feature("docstring")  dolfin::DofMap::mesh "

Return mesh associated with map. ";

%feature("docstring")  dolfin::DofMap::build "

Build parallel dof map. ";

%feature("docstring")  dolfin::DofMap::getMap "

Return renumbering (used for testing). ";


// File: classdolfin_1_1DofMapSet.xml
%feature("docstring") dolfin::DofMapSet "

This class provides storage and caching of (precomputed) dof maps and
enables reuse of already computed dof maps with equal signatures.

C++ includes: DofMapSet.h ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create empty set of dof maps. ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create set of dof maps. ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create set of dof maps (parallel). ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create set of dof maps. ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create set of dof maps (parallel). ";

%feature("docstring")  dolfin::DofMapSet::~DofMapSet "

Destructor. ";

%feature("docstring")  dolfin::DofMapSet::update "

Update set of dof maps for given form. ";

%feature("docstring")  dolfin::DofMapSet::update "

Update set of dof maps for given form (parallel). ";

%feature("docstring")  dolfin::DofMapSet::update "

Update set of dof maps for given form. ";

%feature("docstring")  dolfin::DofMapSet::update "

Update set of dof maps for given form (parallel). ";

%feature("docstring")  dolfin::DofMapSet::size "

Return number of dof maps. ";

%feature("docstring")  dolfin::DofMapSet::build "

Build parallel dof maps. ";

%feature("docstring")  dolfin::DofMapSet::parallel "";


// File: classdolfin_1_1Edge.xml
%feature("docstring") dolfin::Edge "

An Edge is a MeshEntity of topological dimension 1.

C++ includes: Edge.h ";

%feature("docstring")  dolfin::Edge::Edge "

Create edge on given mesh. ";

%feature("docstring")  dolfin::Edge::Edge "

Create edge from mesh entity. ";

%feature("docstring")  dolfin::Edge::~Edge "

Destructor. ";

%feature("docstring")  dolfin::Edge::length "

Compute Euclidian length of edge. ";

%feature("docstring")  dolfin::Edge::midpoint "

Compute coordinates of edge midpoint as a 3D point value. ";


// File: classdolfin_1_1EdgeIterator.xml
%feature("docstring") dolfin::EdgeIterator "

An EdgeIterator is a MeshEntityIterator of topological dimension 1.

C++ includes: Edge.h ";

%feature("docstring")  dolfin::EdgeIterator::EdgeIterator "";

%feature("docstring")  dolfin::EdgeIterator::EdgeIterator "";


// File: classdolfin_1_1ElementLibrary.xml
%feature("docstring") dolfin::ElementLibrary "

Library of pregenerated finite elements and dof maps.

C++ includes: ElementLibrary.h ";


// File: classdolfin_1_1Event.xml
%feature("docstring") dolfin::Event "

A event is a string message which is displayed only a limited number
of times.

Example of usage:

Event event(\"System is stiff, damping is needed.\"); while () { ...
if ( ... ) { event(); ... } }

C++ includes: Event.h ";

%feature("docstring")  dolfin::Event::Event "

Constructor. ";

%feature("docstring")  dolfin::Event::~Event "

Destructor. ";

%feature("docstring")  dolfin::Event::count "

Display count. ";

%feature("docstring")  dolfin::Event::maxcount "

Maximum display count. ";


// File: classdolfin_1_1Face.xml
%feature("docstring") dolfin::Face "

A Face is a MeshEntity of topological dimension 2.

C++ includes: Face.h ";

%feature("docstring")  dolfin::Face::Face "

Constructor. ";

%feature("docstring")  dolfin::Face::~Face "

Destructor. ";


// File: classdolfin_1_1FaceIterator.xml
%feature("docstring") dolfin::FaceIterator "

A FaceIterator is a MeshEntityIterator of topological dimension 2.

C++ includes: Face.h ";

%feature("docstring")  dolfin::FaceIterator::FaceIterator "";

%feature("docstring")  dolfin::FaceIterator::FaceIterator "";


// File: classdolfin_1_1Facet.xml
%feature("docstring") dolfin::Facet "

A Facet is a MeshEntity of topological codimension 1.

C++ includes: Facet.h ";

%feature("docstring")  dolfin::Facet::Facet "

Constructor. ";

%feature("docstring")  dolfin::Facet::~Facet "

Destructor. ";


// File: classdolfin_1_1FacetIterator.xml
%feature("docstring") dolfin::FacetIterator "

A FacetIterator is a MeshEntityIterator of topological codimension 1.

C++ includes: Facet.h ";

%feature("docstring")  dolfin::FacetIterator::FacetIterator "";

%feature("docstring")  dolfin::FacetIterator::FacetIterator "";


// File: classdolfin_1_1FacetNormal.xml
%feature("docstring") dolfin::FacetNormal "

This function represents the outward unit normal on mesh facets. Note
that it is only nonzero on cell facets (not on cells).

C++ includes: SpecialFunctions.h ";

%feature("docstring")  dolfin::FacetNormal::FacetNormal "";

%feature("docstring")  dolfin::FacetNormal::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";


// File: classdolfin_1_1File.xml
%feature("docstring") dolfin::File "

A File represents a data file for reading and writing objects. Unless
specified explicitly, the format is determined by the file name
suffix.

C++ includes: File.h ";

%feature("docstring")  dolfin::File::File "

Create a file with given name. ";

%feature("docstring")  dolfin::File::File "

Create a file with given name and type (format). ";

%feature("docstring")  dolfin::File::~File "

Destructor. ";


// File: classdolfin_1_1Form.xml
%feature("docstring") dolfin::Form "

Base class for UFC code generated by FFC for DOLFIN with option -l.

C++ includes: Form.h ";

%feature("docstring")  dolfin::Form::Form "

Constructor. ";

%feature("docstring")  dolfin::Form::~Form "

Destructor. ";

%feature("docstring")  dolfin::Form::form "

Return UFC form. ";

%feature("docstring")  dolfin::Form::coefficients "

Return array of coefficients. ";

%feature("docstring")  dolfin::Form::updateDofMaps "

Create degree of freedom maps. ";

%feature("docstring")  dolfin::Form::updateDofMaps "

Create degree of freedom maps. ";

%feature("docstring")  dolfin::Form::setDofMaps "

Set degree of freedom maps. ";

%feature("docstring")  dolfin::Form::dofMaps "

Return DofMapSet. ";


// File: classdolfin_1_1Function.xml
%feature("docstring") dolfin::Function "

This class represents a function that can be evaluated on a mesh. The
actual representation of the function can vary, but the typical
representation is in terms of a mesh, a vector of degrees of freedom,
a finite element and a dof map that determines the distribution of
degrees of freedom on the mesh.

It is also possible to have user-defined functions, either by
overloading the eval function of this class or by giving a function
(pointer) that returns the value of the function.

C++ includes: Function.h ";

%feature("docstring")  dolfin::Function::Function "

Create empty function (read data from file). ";

%feature("docstring")  dolfin::Function::Function "

Create user-defined function (evaluation operator must be overloaded).
";

%feature("docstring")  dolfin::Function::Function "

Create constant function from given value. ";

%feature("docstring")  dolfin::Function::Function "

Create constant function from given value.

Create discrete function for argument function i of form ";

%feature("docstring")  dolfin::Function::Function "

Create discrete function for argument function i of form. ";

%feature("docstring")  dolfin::Function::Function "

Create discrete function from sub function. ";

%feature("docstring")  dolfin::Function::Function "

Create function from data file. ";

%feature("docstring")  dolfin::Function::Function "

Copy constructor. ";

%feature("docstring")  dolfin::Function::~Function "

Destructor. ";

%feature("docstring")  dolfin::Function::init "

Create discrete function for argument function i of form. ";

%feature("docstring")  dolfin::Function::init "

Create discrete function for argument function i of form. ";

%feature("docstring")  dolfin::Function::type "

Return the type of function. ";

%feature("docstring")  dolfin::Function::rank "

Return the rank of the value space. ";

%feature("docstring")  dolfin::Function::dim "

Return the dimension of the value space for axis i. ";

%feature("docstring")  dolfin::Function::mesh "

Return the mesh. ";

%feature("docstring")  dolfin::Function::vector "

Return the vector associated with a DiscreteFunction. ";

%feature("docstring")  dolfin::Function::numSubFunctions "

Return the number of sub functions (only for discrete functions). ";

%feature("docstring")  dolfin::Function::interpolate "

Interpolate function to vertices of mesh. ";

%feature("docstring")  dolfin::Function::interpolate "

Interpolate function to finite element space on cell. ";

%feature("docstring")  dolfin::Function::eval "

Evaluate function at given point (used for subclassing through SWIG
interface). ";

%feature("docstring")  dolfin::Function::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";

%feature("docstring")  dolfin::Function::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";


// File: classdolfin_1_1GaussianQuadrature.xml
%feature("docstring") dolfin::GaussianQuadrature "

Gaussian-type quadrature rule on the real line, including Gauss,
Radau, and Lobatto quadrature.

Points and weights are computed to be exact within a tolerance of
DOLFIN_EPS. Comparing with known exact values for n <= 3 shows that we
obtain full precision (16 digits, error less than 2e-16).

C++ includes: GaussianQuadrature.h ";

%feature("docstring")  dolfin::GaussianQuadrature::GaussianQuadrature
"";


// File: classdolfin_1_1GaussQuadrature.xml
%feature("docstring") dolfin::GaussQuadrature "

Gauss (Gauss-Legendre) quadrature on the interval [-1,1]. The n
quadrature points are given by the zeros of the n:th Legendre Pn(x).

The quadrature points are computed using Newton's method, and the
quadrature weights are computed by solving a linear system determined
by the condition that Gauss quadrature with n points should be exact
for polynomials of degree 2n-1.

C++ includes: GaussQuadrature.h ";

%feature("docstring")  dolfin::GaussQuadrature::GaussQuadrature "";

%feature("docstring")  dolfin::GaussQuadrature::disp "

Display quadrature data. ";


// File: classdolfin_1_1GenericMatrix.xml
%feature("docstring") dolfin::GenericMatrix "

This class defines a common interface for matrices.

C++ includes: GenericMatrix.h ";

%feature("docstring")  dolfin::GenericMatrix::GenericMatrix "

Constructor. ";

%feature("docstring")  dolfin::GenericMatrix::~GenericMatrix "

Destructor. ";

%feature("docstring")  dolfin::GenericMatrix::init "

--- Implementation of GenericTensor interface ---

Initialize zero tensor using sparsity pattern (implemented by sub
class) ";

%feature("docstring")  dolfin::GenericMatrix::create "

Create uninitialized matrix. ";

%feature("docstring")  dolfin::GenericMatrix::copy "

Create copy of matrix. ";

%feature("docstring")  dolfin::GenericMatrix::rank "

Return rank of tensor (number of dimensions). ";

%feature("docstring")  dolfin::GenericMatrix::size "

Return size of given dimension (implemented by sub class). ";

%feature("docstring")  dolfin::GenericMatrix::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericMatrix::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericMatrix::add "

Add block of values. ";

%feature("docstring")  dolfin::GenericMatrix::zero "

Set all entries to zero and keep any sparse structure (implemented by
sub class). ";

%feature("docstring")  dolfin::GenericMatrix::apply "

Finalise assembly of tensor (implemented by sub class). ";

%feature("docstring")  dolfin::GenericMatrix::disp "

Display tensor (implemented by sub class). ";

%feature("docstring")  dolfin::GenericMatrix::init "

--- Matrix interface ---

Initialize M x N matrix ";

%feature("docstring")  dolfin::GenericMatrix::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericMatrix::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericMatrix::add "

Add block of values. ";

%feature("docstring")  dolfin::GenericMatrix::ident "

Set given rows to identity matrix. ";


// File: classdolfin_1_1GenericSparsityPattern.xml
%feature("docstring") dolfin::GenericSparsityPattern "

Base class for sparsity patterns of vectors/matrices. Concrete sub
classes can be used to initalise vectors and sparse matrices.

C++ includes: GenericSparsityPattern.h ";

%feature("docstring")
dolfin::GenericSparsityPattern::GenericSparsityPattern "

Constructor. ";

%feature("docstring")
dolfin::GenericSparsityPattern::~GenericSparsityPattern "

Destructor. ";

%feature("docstring")  dolfin::GenericSparsityPattern::init "

Initialise sparsity pattern for a generic tensor. ";

%feature("docstring")  dolfin::GenericSparsityPattern::pinit "

Initialise sparsity pattern for a parallel generic tensor. ";

%feature("docstring")  dolfin::GenericSparsityPattern::insert "

Insert non-zero entry. ";

%feature("docstring")  dolfin::GenericSparsityPattern::pinsert "

Insert non-zero entry. ";

%feature("docstring")  dolfin::GenericSparsityPattern::size "

Return global size. ";

%feature("docstring")
dolfin::GenericSparsityPattern::numNonZeroPerRow "

Return array with number of non-zeroes per row. ";

%feature("docstring")  dolfin::GenericSparsityPattern::numNonZero "

Return total number of non-zeroes. ";

%feature("docstring")  dolfin::GenericSparsityPattern::apply "

Finalize sparsity pattern (needed by most parallel la backends). ";


// File: classdolfin_1_1GenericTensor.xml
%feature("docstring") dolfin::GenericTensor "

This class defines a common interface for general tensors.

C++ includes: GenericTensor.h ";

%feature("docstring")  dolfin::GenericTensor::GenericTensor "

Constructor. ";

%feature("docstring")  dolfin::GenericTensor::~GenericTensor "

Destructor. ";

%feature("docstring")  dolfin::GenericTensor::init "

Initialize zero tensor using sparsity pattern. ";

%feature("docstring")  dolfin::GenericTensor::create "

Create uninitialized tensor. ";

%feature("docstring")  dolfin::GenericTensor::copy "

Create copy of tensor. ";

%feature("docstring")  dolfin::GenericTensor::rank "

Return rank of tensor (number of dimensions). ";

%feature("docstring")  dolfin::GenericTensor::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::GenericTensor::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericTensor::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericTensor::add "

Add block of values. ";

%feature("docstring")  dolfin::GenericTensor::zero "

Set all entries to zero and keep any sparse structure. ";

%feature("docstring")  dolfin::GenericTensor::apply "

Finalise assembly of tensor. ";

%feature("docstring")  dolfin::GenericTensor::disp "

Display tensor. ";

%feature("docstring")  dolfin::GenericTensor::factory "

Get LA backend factory. ";


// File: classdolfin_1_1GenericVector.xml
%feature("docstring") dolfin::GenericVector "

This class defines a common interface for matrices.

C++ includes: GenericVector.h ";

%feature("docstring")  dolfin::GenericVector::GenericVector "

Constructor. ";

%feature("docstring")  dolfin::GenericVector::~GenericVector "

Destructor. ";

%feature("docstring")  dolfin::GenericVector::init "

--- Implementation of GenericTensor interface ---

Initialize zero tensor of given rank and dimensions ";

%feature("docstring")  dolfin::GenericVector::init "

Initialize zero tensor using sparsity pattern. ";

%feature("docstring")  dolfin::GenericVector::create "

Create uninitialized vector. ";

%feature("docstring")  dolfin::GenericVector::copy "

Create copy of vector. ";

%feature("docstring")  dolfin::GenericVector::rank "

Return rank of tensor (number of dimensions). ";

%feature("docstring")  dolfin::GenericVector::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::GenericVector::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericVector::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericVector::add "

Add block of values. ";

%feature("docstring")  dolfin::GenericVector::zero "

Set all entries to zero and keep any sparse structure (implemented by
sub class). ";

%feature("docstring")  dolfin::GenericVector::apply "

Finalise assembly of tensor (implemented by sub class). ";

%feature("docstring")  dolfin::GenericVector::disp "

Display tensor (implemented by sub class). ";

%feature("docstring")  dolfin::GenericVector::init "

--- Vector interface ---

Initialize vector of size N ";

%feature("docstring")  dolfin::GenericVector::size "

Return size. ";

%feature("docstring")  dolfin::GenericVector::get "

Get values. ";

%feature("docstring")  dolfin::GenericVector::set "

Set values. ";

%feature("docstring")  dolfin::GenericVector::add "

Add values. ";

%feature("docstring")  dolfin::GenericVector::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericVector::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericVector::add "

Add block of values. ";


// File: classdolfin_1_1GMRES.xml
%feature("docstring") dolfin::GMRES "

This class provides methods for solving a linear system with the GMRES
method, with an optional preconditioner.

C++ includes: GMRES.h ";


// File: classdolfin_1_1Graph.xml
%feature("docstring") dolfin::Graph "

A Graph consists of a set of vertices and edges.

The graph is stored in Compressed Sparse Row (CSR) format. This format
stores edges and vertices separately in two arrays, with the indices
into these arrays corresponding to the identifier for the vertex or
edge, respectively. The edge array stores the edge destination
vertices while the vertice array stores the offset into the edge
array. E.g. the edges connected to vertex i are: edges[vertices[i]],
edges[vertices[i]+1], ..., edges[vertices[i]-1].

In a graph with n vertices the vertex array will be of size n+1. The
edge array will be of size m in a directed graph and size 2m in a
undirected graph (an edge between vertices u and v is stored as (v,u)
as well as (u,v)).

Example graph: 0 -- 1 | \\\\ | | \\\\ | 2 -- 3

Stored as:

edges = [123030312] vertices = [03579]

Note that the last integer of vertices does not represent a vertex,
but is there to support edge iteration as described above.

CSR format minimizes memory usage and is suitable for large graphs
that do not change.

C++ includes: Graph.h ";

%feature("docstring")  dolfin::Graph::Graph "

Create empty graph. ";

%feature("docstring")  dolfin::Graph::Graph "

Copy constructor. ";

%feature("docstring")  dolfin::Graph::Graph "

Create graph from given file. ";

%feature("docstring")  dolfin::Graph::Graph "

Create graph from mesh. ";

%feature("docstring")  dolfin::Graph::Graph "

Create graph from mesh. ";

%feature("docstring")  dolfin::Graph::Graph "

Create graph from mesh. ";

%feature("docstring")  dolfin::Graph::~Graph "

Destructor. ";

%feature("docstring")  dolfin::Graph::numVertices "

Assignment.

Return number of vertices ";

%feature("docstring")  dolfin::Graph::numEdges "

Return number of edges. ";

%feature("docstring")  dolfin::Graph::numEdges "

Return number of edges incident to vertex u. ";

%feature("docstring")  dolfin::Graph::numArches "

Return number of arches (outgoing edges). ";

%feature("docstring")  dolfin::Graph::adjacent "

Check if vertex u is adjacent to vertex v. ";

%feature("docstring")  dolfin::Graph::edgeWeights "

Return edge weights. ";

%feature("docstring")  dolfin::Graph::vertexWeights "

Return vertex weights. ";

%feature("docstring")  dolfin::Graph::connectivity "

Return array of edges for all vertices. ";

%feature("docstring")  dolfin::Graph::offsets "

Return array of offsets for edges of all vertices. ";

%feature("docstring")  dolfin::Graph::type "

Return graph type. ";

%feature("docstring")  dolfin::Graph::partition "

Partition a graph into num_part partitions. ";

%feature("docstring")  dolfin::Graph::typestr "

Return graph type as a string. ";

%feature("docstring")  dolfin::Graph::disp "

Display graph data. ";

%feature("docstring")  dolfin::Graph::clear "

Clear graph data. ";


// File: classdolfin_1_1GraphEditor.xml
%feature("docstring") dolfin::GraphEditor "

A simple graph editor for creating graphs.

C++ includes: GraphEditor.h ";

%feature("docstring")  dolfin::GraphEditor::GraphEditor "

Constructor. ";

%feature("docstring")  dolfin::GraphEditor::~GraphEditor "

Destructor. ";

%feature("docstring")  dolfin::GraphEditor::open "

Open graph of given type. ";

%feature("docstring")  dolfin::GraphEditor::open "

Open graph of given type. ";

%feature("docstring")  dolfin::GraphEditor::initVertices "

Specify number of vertices. ";

%feature("docstring")  dolfin::GraphEditor::initEdges "

Specify number of edges. ";

%feature("docstring")  dolfin::GraphEditor::addVertex "

Add vertex v. ";

%feature("docstring")  dolfin::GraphEditor::addEdge "

Add edge from vertex u to vertex v. ";

%feature("docstring")  dolfin::GraphEditor::close "

Close graph, finish editing. ";


// File: classdolfin_1_1GraphPartition.xml
%feature("docstring") dolfin::GraphPartition "

This class provides a set of functions to partition a Graph.

C++ includes: GraphPartition.h ";


// File: classdolfin_1_1Homotopy.xml
%feature("docstring") dolfin::Homotopy "";

%feature("docstring")  dolfin::Homotopy::Homotopy "

Create homotopy for system of given size. ";

%feature("docstring")  dolfin::Homotopy::~Homotopy "

Destructor. ";

%feature("docstring")  dolfin::Homotopy::solve "

Solve homotopy. ";

%feature("docstring")  dolfin::Homotopy::solutions "

Return array of solutions found. ";

%feature("docstring")  dolfin::Homotopy::z0 "

Return initial value (solution of G(z) = 0), optional. ";

%feature("docstring")  dolfin::Homotopy::F "

Compute y = F(z). ";

%feature("docstring")  dolfin::Homotopy::JF "

Compute y = F'(z) x. ";

%feature("docstring")  dolfin::Homotopy::G "

Compute y = G(z), optional. ";

%feature("docstring")  dolfin::Homotopy::JG "

Compute y = G'(z) x, optional. ";

%feature("docstring")  dolfin::Homotopy::modify "

Modify or substitute found solution (optional). ";

%feature("docstring")  dolfin::Homotopy::verify "

Check if found solution is correct (optional). ";

%feature("docstring")  dolfin::Homotopy::degree "

Return degree of polynomial F_i(z). ";


// File: classdolfin_1_1IntersectionDetector.xml
%feature("docstring") dolfin::IntersectionDetector "

This class provides an interface for computing intersection (overlap)
between a mesh and an individual cell or point

C++ includes: IntersectionDetector.h ";

%feature("docstring")
dolfin::IntersectionDetector::IntersectionDetector "

Constructor. ";

%feature("docstring")
dolfin::IntersectionDetector::~IntersectionDetector "

Destructor. ";

%feature("docstring")  dolfin::IntersectionDetector::overlap "

Compute overlap with mesh. ";

%feature("docstring")  dolfin::IntersectionDetector::overlap "

Compute overlap with point. ";


// File: classdolfin_1_1InvMeshSize.xml
%feature("docstring") dolfin::InvMeshSize "

This function represents the inverse of the local mesh size on a given
mesh.

C++ includes: SpecialFunctions.h ";

%feature("docstring")  dolfin::InvMeshSize::InvMeshSize "";

%feature("docstring")  dolfin::InvMeshSize::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";


// File: classdolfin_1_1KrylovSolver.xml
%feature("docstring") dolfin::KrylovSolver "

This class defines an interface for a Krylov solver. The underlying
Krylov solver type is defined in default_type.h.

C++ includes: KrylovSolver.h ";

%feature("docstring")  dolfin::KrylovSolver::KrylovSolver "";

%feature("docstring")  dolfin::KrylovSolver::KrylovSolver "";

%feature("docstring")  dolfin::KrylovSolver::KrylovSolver "";

%feature("docstring")  dolfin::KrylovSolver::~KrylovSolver "";

%feature("docstring")  dolfin::KrylovSolver::solve "

Solve linear system Ax = b. ";


// File: classdolfin_1_1Lagrange.xml
%feature("docstring") dolfin::Lagrange "

Lagrange polynomial (basis) with given degree q determined by n = q +
1 nodal points.

Example: q = 1 (n = 2)

Lagrange p(1); p.set(0, 0.0); p.set(1, 1.0);

This creates a Lagrange polynomial (actually two Lagrange
polynomials):

p(0,x) = 1 - x (one at x = 0, zero at x = 1) p(1,x) = x (zero at x =
0, one at x = 1)

C++ includes: Lagrange.h ";

%feature("docstring")  dolfin::Lagrange::Lagrange "

Constructor. ";

%feature("docstring")  dolfin::Lagrange::Lagrange "

Copy constructor. ";

%feature("docstring")  dolfin::Lagrange::~Lagrange "

Destructor. ";

%feature("docstring")  dolfin::Lagrange::set "

Specify point. ";

%feature("docstring")  dolfin::Lagrange::size "

Return number of points. ";

%feature("docstring")  dolfin::Lagrange::degree "

Return degree. ";

%feature("docstring")  dolfin::Lagrange::point "

Return point. ";

%feature("docstring")  dolfin::Lagrange::eval "

Return value of polynomial i at given point x. ";

%feature("docstring")  dolfin::Lagrange::ddx "

Return derivate of polynomial i at given point x. ";

%feature("docstring")  dolfin::Lagrange::dqdx "

Return derivative q (a constant) of polynomial. ";

%feature("docstring")  dolfin::Lagrange::disp "";


// File: classdolfin_1_1Legendre.xml
%feature("docstring") dolfin::Legendre "

Legendre polynomial of given degree n on the interval [-1,1].

P0(x) = 1 P1(x) = x P2(x) = (3x^2 - 1) / 2 ...

The function values and derivatives are computed using three-term
recurrence formulas.

C++ includes: Legendre.h ";

%feature("docstring")  dolfin::Legendre::Legendre "";

%feature("docstring")  dolfin::Legendre::ddx "

Evaluation of derivative at given point. ";

%feature("docstring")  dolfin::Legendre::d2dx "

Evaluation of second derivative at given point. ";


// File: classdolfin_1_1LinearAlgebraFactory.xml
%feature("docstring") dolfin::LinearAlgebraFactory "";

%feature("docstring")
dolfin::LinearAlgebraFactory::LinearAlgebraFactory "

Constructor. ";

%feature("docstring")
dolfin::LinearAlgebraFactory::~LinearAlgebraFactory "

Destructor. ";

%feature("docstring")  dolfin::LinearAlgebraFactory::createMatrix "

Create empty matrix. ";

%feature("docstring")  dolfin::LinearAlgebraFactory::createPattern "

Create empty sparsity pattern. ";

%feature("docstring")  dolfin::LinearAlgebraFactory::createVector "

Create empty vector. ";


// File: classdolfin_1_1LinearPDE.xml
%feature("docstring") dolfin::LinearPDE "

A LinearPDE represents a (system of) linear partial differential
equation(s) in variational form: Find u in V such that

a(v, u) = L(v) for all v in V',

where a is a bilinear form and L is a linear form.

C++ includes: LinearPDE.h ";

%feature("docstring")  dolfin::LinearPDE::LinearPDE "

Define a linear PDE with natural boundary conditions. ";

%feature("docstring")  dolfin::LinearPDE::LinearPDE "

Define a linear PDE with a single Dirichlet boundary condition. ";

%feature("docstring")  dolfin::LinearPDE::LinearPDE "

Define a linear PDE with a set of Dirichlet boundary conditions. ";

%feature("docstring")  dolfin::LinearPDE::~LinearPDE "

Destructor. ";

%feature("docstring")  dolfin::LinearPDE::solve "

Solve PDE system. ";

%feature("docstring")  dolfin::LinearPDE::solve "

Solve PDE system and extract sub functions. ";

%feature("docstring")  dolfin::LinearPDE::solve "

Solve PDE system and extract sub functions. ";


// File: classdolfin_1_1LinearSolver.xml
%feature("docstring") dolfin::LinearSolver "

This class defines the interfaces for default linear solvers for
systems of the form Ax = b.

C++ includes: LinearSolver.h ";

%feature("docstring")  dolfin::LinearSolver::LinearSolver "

Constructor. ";

%feature("docstring")  dolfin::LinearSolver::~LinearSolver "

Destructor. ";

%feature("docstring")  dolfin::LinearSolver::solve "

Solve linear system Ax = b. ";


// File: classdolfin_1_1List.xml
%feature("docstring") dolfin::List "

List is a container that provides O(n) access time to elements and
O(n) memory overhead. However, a List can be grown/shrunk without
reallocation and spliced together with other lists, etc.

It is a wrapper for std::list (doubly-linked list), so see the STL
manual for further details:http://www.sgi.com/tech/stl/

C++ includes: List.h ";

%feature("docstring")  dolfin::List::List "

Create empty list. ";

%feature("docstring")  dolfin::List::List "

Copy constructor. ";


// File: classdolfin_1_1LobattoQuadrature.xml
%feature("docstring") dolfin::LobattoQuadrature "

Lobatto (Gauss-Lobatto) quadrature on the interval [-1,1]. The n
quadrature points are given by the end-points -1 and 1, and the zeros
of P{n-1}'(x), where P{n-1}(x) is the (n-1):th Legendre polynomial.

The quadrature points are computed using Newton's method, and the
quadrature weights are computed by solving a linear system determined
by the condition that Lobatto quadrature with n points should be exact
for polynomials of degree 2n-3.

C++ includes: LobattoQuadrature.h ";

%feature("docstring")  dolfin::LobattoQuadrature::LobattoQuadrature "";

%feature("docstring")  dolfin::LobattoQuadrature::disp "

Display quadrature data. ";


// File: classdolfin_1_1LogStream.xml
%feature("docstring") dolfin::LogStream "";

%feature("docstring")  dolfin::LogStream::LogStream "";

%feature("docstring")  dolfin::LogStream::~LogStream "";

%feature("docstring")  dolfin::LogStream::disp "";


// File: classdolfin_1_1LU.xml
%feature("docstring") dolfin::LU "

This class provides methods for solving a linear system by LU
factorization.

C++ includes: LU.h ";


// File: classdolfin_1_1LUSolver.xml
%feature("docstring") dolfin::LUSolver "";

%feature("docstring")  dolfin::LUSolver::LUSolver "

This class defines an interface for a LU solver. The underlying type
of LU is defined in default_la_types.h. ";

%feature("docstring")  dolfin::LUSolver::~LUSolver "";

%feature("docstring")  dolfin::LUSolver::solve "";


// File: classdolfin_1_1Matrix.xml
%feature("docstring") dolfin::Matrix "

This class provides an interface to the default DOLFIN matrix
implementation as decided in default_la_types.h.

C++ includes: Matrix.h ";

%feature("docstring")  dolfin::Matrix::Matrix "

Constructor. ";

%feature("docstring")  dolfin::Matrix::Matrix "

Constructor. ";

%feature("docstring")  dolfin::Matrix::~Matrix "

Destructor. ";

%feature("docstring")  dolfin::Matrix::init "

Initialize M x N matrix. ";

%feature("docstring")  dolfin::Matrix::init "

Initialize zero matrix using sparsity pattern. ";

%feature("docstring")  dolfin::Matrix::create "

Create uninitialized matrix. ";

%feature("docstring")  dolfin::Matrix::copy "

Create copy of matrix. ";

%feature("docstring")  dolfin::Matrix::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::Matrix::get "

Get block of values. ";

%feature("docstring")  dolfin::Matrix::set "

Set block of values. ";

%feature("docstring")  dolfin::Matrix::add "

Add block of values. ";

%feature("docstring")  dolfin::Matrix::zero "

Set all entries to zero and keep any sparse structure (implemented by
sub class). ";

%feature("docstring")  dolfin::Matrix::ident "

Set given rows to identity matrix. ";

%feature("docstring")  dolfin::Matrix::apply "

Finalise assembly of matrix. ";

%feature("docstring")  dolfin::Matrix::disp "

Display matrix (sparse output is default). ";

%feature("docstring")  dolfin::Matrix::getRow "

Get non-zero values of row i.

FIXME: Functions below are not in the GenericVector interface. FIXME:
Should these be removed or added to the interface? ";

%feature("docstring")  dolfin::Matrix::mat "

Return const reference to implementation. ";

%feature("docstring")  dolfin::Matrix::mat "

Return const reference to implementation. ";

%feature("docstring")  dolfin::Matrix::factory "

Get LA backend factory. ";


// File: classdolfin_1_1MatrixFactory.xml
%feature("docstring") dolfin::MatrixFactory "

This class provides functionality for computing a set of standard
finite element matrices, such as the mass matrix and the stiffness
matrix, with piecewise linear elements. For other matrices (forms) and
elements, forms must be defined in the FFC form language and
assembled.

C++ includes: MatrixFactory.h ";


// File: classdolfin_1_1Mesh.xml
%feature("docstring") dolfin::Mesh "

A Mesh consists of a set of connected and numbered mesh entities.

Both the representation and the interface are dimension-independent,
but a concrete interface is also provided for standard named mesh
entities:

Entity Dimension Codimension

Vertex 0 - Edge 1 - Face 2 -

Facet - 1 Cell - 0

When working with mesh iterators, all entities and connectivity are
precomputed automatically the first time an iterator is created over
any given topological dimension or connectivity.

C++ includes: Mesh.h ";

%feature("docstring")  dolfin::Mesh::Mesh "

Create empty mesh. ";

%feature("docstring")  dolfin::Mesh::Mesh "

Copy constructor. ";

%feature("docstring")  dolfin::Mesh::Mesh "

Create mesh from data file. ";

%feature("docstring")  dolfin::Mesh::~Mesh "

Destructor. ";

%feature("docstring")  dolfin::Mesh::numVertices "

Return number of vertices. ";

%feature("docstring")  dolfin::Mesh::numEdges "

Return number of edges. ";

%feature("docstring")  dolfin::Mesh::numFaces "

Return number of faces. ";

%feature("docstring")  dolfin::Mesh::numFacets "

Return number of facets. ";

%feature("docstring")  dolfin::Mesh::numCells "

Return number of cells. ";

%feature("docstring")  dolfin::Mesh::coordinates "

Return coordinates of all vertices. ";

%feature("docstring")  dolfin::Mesh::coordinates "

Return coordinates of all vertices. ";

%feature("docstring")  dolfin::Mesh::cells "

Return connectivity for all cells. ";

%feature("docstring")  dolfin::Mesh::cells "

Return connectivity for all cells. ";

%feature("docstring")  dolfin::Mesh::size "

Return number of entities of given topological dimension. ";

%feature("docstring")  dolfin::Mesh::topology "

Return mesh topology. ";

%feature("docstring")  dolfin::Mesh::topology "

Return mesh topology. ";

%feature("docstring")  dolfin::Mesh::geometry "

Return mesh geometry. ";

%feature("docstring")  dolfin::Mesh::geometry "

Return mesh geometry. ";

%feature("docstring")  dolfin::Mesh::type "

Return mesh cell type. ";

%feature("docstring")  dolfin::Mesh::type "

Return mesh cell type. ";

%feature("docstring")  dolfin::Mesh::init "

Compute entities of given topological dimension and return number of
entities. ";

%feature("docstring")  dolfin::Mesh::init "

Compute connectivity between given pair of dimensions. ";

%feature("docstring")  dolfin::Mesh::init "

Compute all entities and connectivity. ";

%feature("docstring")  dolfin::Mesh::order "

Order all mesh entities (not needed if \"mesh order entities\" is
set). ";

%feature("docstring")  dolfin::Mesh::refine "

Refine mesh uniformly. ";

%feature("docstring")  dolfin::Mesh::refine "

Refine mesh according to cells marked for refinement. ";

%feature("docstring")  dolfin::Mesh::coarsen "

Coarsen mesh uniformly. ";

%feature("docstring")  dolfin::Mesh::coarsen "

Coarsen mesh according to cells marked for coarsening. ";

%feature("docstring")  dolfin::Mesh::smooth "

Smooth mesh using Lagrangian mesh smoothing. ";

%feature("docstring")  dolfin::Mesh::partition "

Partition mesh into num_processes partitions. ";

%feature("docstring")  dolfin::Mesh::partition "

Partition mesh into num_partitions partitions. ";

%feature("docstring")  dolfin::Mesh::disp "

Display mesh data. ";

%feature("docstring")  dolfin::Mesh::str "

Return a short desriptive string. ";


// File: classdolfin_1_1MeshConnectivity.xml
%feature("docstring") dolfin::MeshConnectivity "

Mesh connectivity stores a sparse data structure of connections
(incidence relations) between mesh entities for a fixed pair of
topological dimensions.

The connectivity can be specified either by first giving the number of
entities and the number of connections for each entity, which may
either be equal for all entities or different, or by giving the entire
(sparse) connectivity pattern.

C++ includes: MeshConnectivity.h ";

%feature("docstring")  dolfin::MeshConnectivity::MeshConnectivity "

Create empty connectivity. ";

%feature("docstring")  dolfin::MeshConnectivity::MeshConnectivity "

Copy constructor. ";

%feature("docstring")  dolfin::MeshConnectivity::~MeshConnectivity "

Destructor. ";

%feature("docstring")  dolfin::MeshConnectivity::size "

Return total number of connections. ";

%feature("docstring")  dolfin::MeshConnectivity::size "

Return number of connections for given entity. ";

%feature("docstring")  dolfin::MeshConnectivity::clear "

Clear all data. ";

%feature("docstring")  dolfin::MeshConnectivity::init "

Initialize number of entities and number of connections (equal for
all). ";

%feature("docstring")  dolfin::MeshConnectivity::init "

Initialize number of entities and number of connections
(individually). ";

%feature("docstring")  dolfin::MeshConnectivity::set "

Set given connection for given entity. ";

%feature("docstring")  dolfin::MeshConnectivity::set "

Set all connections for given entity. ";

%feature("docstring")  dolfin::MeshConnectivity::set "

Set all connections for given entity. ";

%feature("docstring")  dolfin::MeshConnectivity::set "

Set all connections for all entities. ";

%feature("docstring")  dolfin::MeshConnectivity::disp "

Display data. ";


// File: classdolfin_1_1MeshEditor.xml
%feature("docstring") dolfin::MeshEditor "

A simple mesh editor for creating simplicial meshes in 1D, 2D and 3D.

C++ includes: MeshEditor.h ";

%feature("docstring")  dolfin::MeshEditor::MeshEditor "

Constructor. ";

%feature("docstring")  dolfin::MeshEditor::~MeshEditor "

Destructor. ";

%feature("docstring")  dolfin::MeshEditor::open "

Open mesh of given cell type, topological and geometrical dimension.
";

%feature("docstring")  dolfin::MeshEditor::open "

Open mesh of given cell type, topological and geometrical dimension.
";

%feature("docstring")  dolfin::MeshEditor::initVertices "

Specify number of vertices. ";

%feature("docstring")  dolfin::MeshEditor::initCells "

Specify number of cells. ";

%feature("docstring")  dolfin::MeshEditor::addVertex "

Add vertex v at given point p. ";

%feature("docstring")  dolfin::MeshEditor::addVertex "

Add vertex v at given coordinate x. ";

%feature("docstring")  dolfin::MeshEditor::addVertex "

Add vertex v at given coordinate (x, y). ";

%feature("docstring")  dolfin::MeshEditor::addVertex "

Add vertex v at given coordinate (x, y, z). ";

%feature("docstring")  dolfin::MeshEditor::addCell "

Add cell with given vertices. ";

%feature("docstring")  dolfin::MeshEditor::addCell "

Add cell (interval) with given vertices. ";

%feature("docstring")  dolfin::MeshEditor::addCell "

Add cell (triangle) with given vertices. ";

%feature("docstring")  dolfin::MeshEditor::addCell "

Add cell (tetrahedron) with given vertices. ";

%feature("docstring")  dolfin::MeshEditor::close "

Close mesh, finish editing. ";


// File: classdolfin_1_1MeshEntity.xml
%feature("docstring") dolfin::MeshEntity "

A MeshEntity represents a mesh entity associated with a specific
topological dimension of some mesh.

C++ includes: MeshEntity.h ";

%feature("docstring")  dolfin::MeshEntity::MeshEntity "

Constructor. ";

%feature("docstring")  dolfin::MeshEntity::~MeshEntity "

Destructor. ";

%feature("docstring")  dolfin::MeshEntity::mesh "

Return mesh associated with mesh entity. ";

%feature("docstring")  dolfin::MeshEntity::mesh "

Return mesh associated with mesh entity. ";

%feature("docstring")  dolfin::MeshEntity::dim "

Return topological dimension. ";

%feature("docstring")  dolfin::MeshEntity::index "

Return index of mesh entity. ";

%feature("docstring")  dolfin::MeshEntity::numEntities "

Return number of incident mesh entities of given topological
dimension. ";

%feature("docstring")  dolfin::MeshEntity::entities "

Return array of indices for incident mesh entitites of given
topological dimension. ";

%feature("docstring")  dolfin::MeshEntity::entities "

Return array of indices for incident mesh entitites of given
topological dimension. ";

%feature("docstring")  dolfin::MeshEntity::incident "

Check if given entity is indicent. ";

%feature("docstring")  dolfin::MeshEntity::index "

Compute local index of given incident entity (error if not found). ";


// File: classdolfin_1_1MeshEntityIterator.xml
%feature("docstring") dolfin::MeshEntityIterator "

MeshEntityIterator provides a common iterator for mesh entities over
meshes, boundaries and incidence relations. The basic use is
illustrated below.

The following example shows how to iterate over all mesh entities of a
mesh of topological dimension dim:

for ( MeshEntityIterator e(mesh, dim); !e. end(); ++e) { e->foo(); }

The following example shows how to iterate over mesh entities of
topological dimension dim connected (incident) to some mesh entity f:

for ( MeshEntityIterator e(f, dim); !e. end(); ++e) { e->foo(); }

In addition to the general iterator, a set of specific named iterators
are provided for entities of type Vertex, Edge, Face, Facet and Cell.
These iterators are defined along with their respective classes.

C++ includes: MeshEntityIterator.h ";

%feature("docstring")  dolfin::MeshEntityIterator::MeshEntityIterator
"

Create iterator for mesh entities over given topological dimension. ";

%feature("docstring")  dolfin::MeshEntityIterator::MeshEntityIterator
"

Create iterator for entities of given dimension connected to given
entity. ";

%feature("docstring")  dolfin::MeshEntityIterator::~MeshEntityIterator
"

Destructor. ";

%feature("docstring")  dolfin::MeshEntityIterator::pos "

Return current position. ";

%feature("docstring")  dolfin::MeshEntityIterator::end "

Check if iterator has reached the end. ";


// File: classdolfin_1_1MeshFunction.xml
%feature("docstring") dolfin::MeshFunction "

A MeshFunction is a function that can be evaluated at a set of mesh
entities. A MeshFunction is discrete and is only defined at the set of
mesh entities of a fixed topological dimension. A MeshFunction may for
example be used to store a global numbering scheme for the entities of
a (parallel) mesh, marking sub domains or boolean markers for mesh
refinement.

C++ includes: MeshFunction.h ";

%feature("docstring")  dolfin::MeshFunction::MeshFunction "

Create empty mesh function. ";

%feature("docstring")  dolfin::MeshFunction::MeshFunction "

Create empty mesh function on given mesh. ";

%feature("docstring")  dolfin::MeshFunction::MeshFunction "

Create mesh function on given mesh of given dimension. ";

%feature("docstring")  dolfin::MeshFunction::MeshFunction "

Create function from data file. ";

%feature("docstring")  dolfin::MeshFunction::~MeshFunction "

Destructor. ";

%feature("docstring")  dolfin::MeshFunction::mesh "

Return mesh associated with mesh function. ";

%feature("docstring")  dolfin::MeshFunction::dim "

Return topological dimension. ";

%feature("docstring")  dolfin::MeshFunction::size "

Return size (number of entities). ";

%feature("docstring")  dolfin::MeshFunction::values "

Return array of values. ";

%feature("docstring")  dolfin::MeshFunction::values "

Return array of values. ";

%feature("docstring")  dolfin::MeshFunction::init "

Initialize mesh function for given topological dimension. ";

%feature("docstring")  dolfin::MeshFunction::init "

Initialize mesh function for given topological dimension of given
size. ";

%feature("docstring")  dolfin::MeshFunction::init "

Initialize mesh function for given topological dimension. ";

%feature("docstring")  dolfin::MeshFunction::init "

Initialize mesh function for given topological dimension of given
size. ";

%feature("docstring")  dolfin::MeshFunction::get "

Get value at given entity. ";

%feature("docstring")  dolfin::MeshFunction::get "

Get value at given entity. ";

%feature("docstring")  dolfin::MeshFunction::set "

Set value at given entity. ";

%feature("docstring")  dolfin::MeshFunction::set "

Set value at given entity. ";

%feature("docstring")  dolfin::MeshFunction::disp "

Display mesh function data. ";


// File: classdolfin_1_1MeshGeometry.xml
%feature("docstring") dolfin::MeshGeometry "

MeshGeometry stores the geometry imposed on a mesh. Currently, the
geometry is represented by the set of coordinates for the vertices of
a mesh, but other representations are possible.

C++ includes: MeshGeometry.h ";

%feature("docstring")  dolfin::MeshGeometry::MeshGeometry "

Create empty set of coordinates. ";

%feature("docstring")  dolfin::MeshGeometry::MeshGeometry "

Copy constructor. ";

%feature("docstring")  dolfin::MeshGeometry::~MeshGeometry "

Destructor. ";

%feature("docstring")  dolfin::MeshGeometry::dim "

Return Euclidean dimension of coordinate system. ";

%feature("docstring")  dolfin::MeshGeometry::size "

Return number of coordinates. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return value of coordinate n in direction i. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return value of coordinate n in direction i. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return array of values for coordinate n. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return array of values for coordinate n. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return array of values for all coordinates. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return array of values for all coordinates. ";

%feature("docstring")  dolfin::MeshGeometry::point "

Return coordinate n as a 3D point value. ";

%feature("docstring")  dolfin::MeshGeometry::clear "

Clear all data. ";

%feature("docstring")  dolfin::MeshGeometry::init "

Initialize coordinate list to given dimension and size. ";

%feature("docstring")  dolfin::MeshGeometry::set "

Set value of coordinate n in direction i. ";

%feature("docstring")  dolfin::MeshGeometry::disp "

Display data. ";


// File: classdolfin_1_1MeshSize.xml
%feature("docstring") dolfin::MeshSize "

This function represents the local mesh size on a given mesh.

C++ includes: SpecialFunctions.h ";

%feature("docstring")  dolfin::MeshSize::MeshSize "";

%feature("docstring")  dolfin::MeshSize::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";


// File: classdolfin_1_1MeshTopology.xml
%feature("docstring") dolfin::MeshTopology "

MeshTopology stores the topology of a mesh, consisting of mesh
entities and connectivity (incidence relations for the mesh entities).
Note that the mesh entities don't need to be stored, only the number
of entities and the connectivity. Any numbering scheme for the mesh
entities is stored separately in a MeshFunction over the entities.

A mesh entity e may be identified globally as a pair e = (dim, i),
where dim is the topological dimension and i is the index of the
entity within that topological dimension.

C++ includes: MeshTopology.h ";

%feature("docstring")  dolfin::MeshTopology::MeshTopology "

Create empty mesh topology. ";

%feature("docstring")  dolfin::MeshTopology::MeshTopology "

Copy constructor. ";

%feature("docstring")  dolfin::MeshTopology::~MeshTopology "

Destructor. ";

%feature("docstring")  dolfin::MeshTopology::dim "

Return topological dimension. ";

%feature("docstring")  dolfin::MeshTopology::size "

Return number of entities for given dimension. ";

%feature("docstring")  dolfin::MeshTopology::clear "

Clear all data. ";

%feature("docstring")  dolfin::MeshTopology::init "

Initialize topology of given maximum dimension. ";

%feature("docstring")  dolfin::MeshTopology::init "

Set number of entities (size) for given topological dimension. ";

%feature("docstring")  dolfin::MeshTopology::disp "

Display data. ";


// File: classdolfin_1_1Method.xml
%feature("docstring") dolfin::Method "

Base class for cGqMethod and dGqMethod, which contain all numeric
constants, such as nodal points and nodal weights, needed for the
method.

C++ includes: Method.h ";

%feature("docstring")  dolfin::Method::Method "

Constructor. ";

%feature("docstring")  dolfin::Method::~Method "

Destructor. ";

%feature("docstring")  dolfin::Method::type "

Return type (inline optimized). ";

%feature("docstring")  dolfin::Method::degree "

Return degree (inline optimized). ";

%feature("docstring")  dolfin::Method::order "

Return order (inline optimized). ";

%feature("docstring")  dolfin::Method::nsize "

Return number of nodal points (inline optimized). ";

%feature("docstring")  dolfin::Method::qsize "

Return number of quadrature points (inline optimized). ";

%feature("docstring")  dolfin::Method::npoint "

Return nodal point (inline optimized). ";

%feature("docstring")  dolfin::Method::qpoint "

Return quadrature point (inline optimized). ";

%feature("docstring")  dolfin::Method::nweight "

Return nodal weight j for node i, including quadrature (inline
optimized). ";

%feature("docstring")  dolfin::Method::qweight "

Return quadrature weight, including only quadrature (inline
optimized). ";

%feature("docstring")  dolfin::Method::eval "

Evaluation of trial space basis function i at given tau (inline
optimized). ";

%feature("docstring")  dolfin::Method::derivative "

Evaluation of derivative of basis function i at t = 1 (inline
optimized). ";

%feature("docstring")  dolfin::Method::update "

Update solution values using fixed-point iteration. ";

%feature("docstring")  dolfin::Method::update "

Update solution values using fixed-point iteration (damped version).
";

%feature("docstring")  dolfin::Method::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::Method::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::Method::ueval "

Evaluate solution at given node. ";

%feature("docstring")  dolfin::Method::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::Method::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::Method::timestep "

Compute new time step based on the given residual. ";

%feature("docstring")  dolfin::Method::error "

Compute error estimate (modulo stability factor). ";

%feature("docstring")  dolfin::Method::disp "

Display method data. ";


// File: classdolfin_1_1MPIMeshCommunicator.xml
%feature("docstring") dolfin::MPIMeshCommunicator "

The class facilitates the transfer of a mesh between processes using
MPI.

C++ includes: MPIMeshCommunicator.h ";

%feature("docstring")
dolfin::MPIMeshCommunicator::MPIMeshCommunicator "

Constructor. ";

%feature("docstring")
dolfin::MPIMeshCommunicator::~MPIMeshCommunicator "

Destructor. ";


// File: classdolfin_1_1NewtonSolver.xml
%feature("docstring") dolfin::NewtonSolver "

This class defines a Newton solver for equations of the form F(u) = 0.

C++ includes: NewtonSolver.h ";

%feature("docstring")  dolfin::NewtonSolver::NewtonSolver "

Initialise nonlinear solver and choose LU solver. ";

%feature("docstring")  dolfin::NewtonSolver::NewtonSolver "

Initialise nonlinear solver and choose Krylov solver and
preconditioner. ";

%feature("docstring")  dolfin::NewtonSolver::~NewtonSolver "

Destructor. ";

%feature("docstring")  dolfin::NewtonSolver::solve "

Solve abstract nonlinear problem F(x) = 0 for given vector F and
Jacobian dF/dx ";

%feature("docstring")  dolfin::NewtonSolver::getIteration "

Return Newton iteration number. ";


// File: classdolfin_1_1NonlinearPDE.xml
%feature("docstring") dolfin::NonlinearPDE "

This class provides automated solution of nonlinear PDEs.

C++ includes: NonlinearPDE.h ";

%feature("docstring")  dolfin::NonlinearPDE::NonlinearPDE "

Constructor. ";

%feature("docstring")  dolfin::NonlinearPDE::NonlinearPDE "

Constructor. ";

%feature("docstring")  dolfin::NonlinearPDE::~NonlinearPDE "

Destructor. ";

%feature("docstring")  dolfin::NonlinearPDE::update "

Function called before Jacobian matrix and RHS vector are formed.
Users can supply this function to perform updates. ";

%feature("docstring")  dolfin::NonlinearPDE::form "

User-defined function to compute F(u) its Jacobian. ";

%feature("docstring")  dolfin::NonlinearPDE::solve "

Solve PDE. ";


// File: classdolfin_1_1NonlinearProblem.xml
%feature("docstring") dolfin::NonlinearProblem "

This is a base class for nonlinear problems which can return the
nonlinear function F(u) and its Jacobian J = dF(u)/du.

C++ includes: NonlinearProblem.h ";

%feature("docstring")  dolfin::NonlinearProblem::NonlinearProblem "

Create nonlinear problem. ";

%feature("docstring")  dolfin::NonlinearProblem::~NonlinearProblem "

Destructor. ";

%feature("docstring")  dolfin::NonlinearProblem::form "

User-defined function to compute F(u) its Jacobian. ";

%feature("docstring")  dolfin::NonlinearProblem::F "

User-defined function to compute F(u). ";

%feature("docstring")  dolfin::NonlinearProblem::J "

User-defined function to compute Jacobian matrix. ";


// File: classdolfin_1_1ODE.xml
%feature("docstring") dolfin::ODE "

A ODE represents an initial value problem of the form

u'(t) = f(u(t),t) on (0,T],

u(0) = u0,

where u(t) is a vector of length N.

To define an ODE, a user must create a subclass of ODE and create the
function u0() defining the initial condition, as well the function f()
defining the right-hand side.

DOLFIN provides two types of ODE solvers: a set of standard mono-
adaptive solvers with equal adaptive time steps for all components as
well as a set of multi-adaptive solvers with individual and adaptive
time steps for the different components. The right-hand side f() is
defined differently for the two sets of methods, with the multi-
adaptive solvers requiring a component-wise evaluation of the right-
hand side. Only one right-hand side function f() needs to be defined
for use of any particular solver.

It is also possible to solve implicit systems of the form

M(u(t), t) u'(t) = f(u(t),t) on (0,T],

u(0) = u0,

by setting the option \"implicit\" to true and defining the function
M().

C++ includes: ODE.h ";

%feature("docstring")  dolfin::ODE::ODE "

Create an ODE of size N with final time T. ";

%feature("docstring")  dolfin::ODE::~ODE "

Destructor. ";

%feature("docstring")  dolfin::ODE::u0 "

Set initial values. ";

%feature("docstring")  dolfin::ODE::f "

Evaluate right-hand side y = f(u, t), mono-adaptive version (default,
optional). ";

%feature("docstring")  dolfin::ODE::f "

Evaluate right-hand side f_i(u, t), multi-adaptive version (optional).
";

%feature("docstring")  dolfin::ODE::M "

Compute product y = Mx for implicit system (optional). ";

%feature("docstring")  dolfin::ODE::J "

Compute product y = Jx for Jacobian J (optional). ";

%feature("docstring")  dolfin::ODE::Jmatrix "

Compute Jacobian matrix J (optional). ";

%feature("docstring")  dolfin::ODE::Mmatrix "

Compute LHS matrix M (optional). ";

%feature("docstring")  dolfin::ODE::dfdu "

Compute entry of Jacobian (optional). ";

%feature("docstring")  dolfin::ODE::timestep "

Time step to use for the whole system at a given time t (optional). ";

%feature("docstring")  dolfin::ODE::timestep "

Time step to use for a given component at a given time t (optional).
";

%feature("docstring")  dolfin::ODE::update "

Update ODE, return false to stop (optional). ";

%feature("docstring")  dolfin::ODE::save "

Save sample (optional). ";

%feature("docstring")  dolfin::ODE::sparse "

Automatically detect sparsity (optional). ";

%feature("docstring")  dolfin::ODE::sparse "

Compute sparsity from given matrix (optional). ";

%feature("docstring")  dolfin::ODE::size "

Return number of components N. ";

%feature("docstring")  dolfin::ODE::endtime "

Return end time (final time T). ";

%feature("docstring")  dolfin::ODE::solve "

Solve ODE. ";


// File: classdolfin_1_1Parameter.xml
%feature("docstring") dolfin::Parameter "

This class represents a parameter of some given type. Supported value
types are real, int, bool, and string.

C++ includes: Parameter.h ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create int-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create int-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create real-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create bool-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create string-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create string-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Copy constructor. ";

%feature("docstring")  dolfin::Parameter::~Parameter "

Destructor. ";

%feature("docstring")  dolfin::Parameter::type "

Return type of parameter. ";


// File: classdolfin_1_1Parametrized.xml
%feature("docstring") dolfin::Parametrized "

This is a base class for parametrized classes. Each object of a
parametrized class holds a local database of parameters that override
the global database of parameters.

Hierarchies of parametrized objects may be created with the property
that each object inherits the parameters of its parent and all
parameters inherited by the parent. A parameter takes the value of the
first value specified in the hierarchy, starting at the current object
and following the parents back to the global database.

Thus, a parameter that has not been specified, using the set()
function, in any given object, takes the value specified for the
parent, whereas any parameter value that has been specified locally
overrides the value specified for the parent.

C++ includes: Parametrized.h ";

%feature("docstring")  dolfin::Parametrized::Parametrized "

Constructor. ";

%feature("docstring")  dolfin::Parametrized::~Parametrized "

Destructor. ";

%feature("docstring")  dolfin::Parametrized::add "

Add local parameter. ";

%feature("docstring")  dolfin::Parametrized::set "

Set value of local parameter. ";

%feature("docstring")  dolfin::Parametrized::set "

Set parent from which to inherit parameters (key must be \"parent\").
";

%feature("docstring")  dolfin::Parametrized::get "

Get value of parameter with given key (local or nonlocal). ";

%feature("docstring")  dolfin::Parametrized::has "

Check if parameter with given key has been defined locally. ";

%feature("docstring")  dolfin::Parametrized::readParameters "

Callback for changes in parameter values. ";


// File: classdolfin_1_1pAssembler.xml
%feature("docstring") dolfin::pAssembler "

This class provides automated assembly of linear systems, or more
generally, assembly of a sparse tensor from a given variational form.

C++ includes: pAssembler.h ";

%feature("docstring")  dolfin::pAssembler::pAssembler "

Constructor. ";

%feature("docstring")  dolfin::pAssembler::pAssembler "

Constructor. ";

%feature("docstring")  dolfin::pAssembler::~pAssembler "

Destructor. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble tensor from given variational form. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble tensor from given variational form over a sub domain. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble tensor from given variational form over sub domains. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble scalar from given variational form. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble scalar from given variational form over a sub domain. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble scalar from given variational form over sub domains. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble tensor from given (UFC) form, coefficients and sub domains.
This is the main assembly function in DOLFIN. All other assembly
functions end up calling this function.

The MeshFunction arguments can be used to specify assembly over
subdomains of the mesh cells, exterior facets and interior facets.
Either a null pointer or an empty MeshFunction may be used to specify
that the tensor should be assembled over the entire set of cells or
facets. ";


// File: classdolfin_1_1PeriodicBC.xml
%feature("docstring") dolfin::PeriodicBC "

This class specifies the interface for setting periodic boundary
conditions for partial differential equations,

u(x) = u(F^{-1}(x)) on G, u(x) = u(F(x)) on H,

where F : H --> G is a map from a subdomain H to a subdomain G.

A PeriodicBC is specified by a Mesh and a SubDomain. The given
subdomain must overload both the inside() function, which specifies
the points of G, and the map() function, which specifies the map from
the points of H to the points of G.

For mixed systems (vector-valued and mixed elements), an optional set
of parameters may be used to specify for which sub system the boundary
condition should be specified.

C++ includes: PeriodicBC.h ";

%feature("docstring")  dolfin::PeriodicBC::PeriodicBC "

Create periodic boundary condition for sub domain. ";

%feature("docstring")  dolfin::PeriodicBC::PeriodicBC "

Create sub system boundary condition for sub domain. ";

%feature("docstring")  dolfin::PeriodicBC::~PeriodicBC "

Destructor. ";

%feature("docstring")  dolfin::PeriodicBC::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::PeriodicBC::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::PeriodicBC::apply "

Apply boundary condition to linear system for a nonlinear problem (not
implemented). ";

%feature("docstring")  dolfin::PeriodicBC::apply "

Apply boundary condition to linear system for a nonlinear problem (not
implemented). ";


// File: classdolfin_1_1PETScObject.xml
%feature("docstring") dolfin::PETScObject "

This class calls SubSystemsManger to initialise PETSc.

All PETSc objects must be derived from this class.

C++ includes: PETScObject.h ";

%feature("docstring")  dolfin::PETScObject::PETScObject "";


// File: classdolfin_1_1Point.xml
%feature("docstring") dolfin::Point "

A Point represents a point in R^3 with coordinates x, y, z, or,
alternatively, a vector in R^3, supporting standard operations like
the norm, distances, scalar and vector products etc.

C++ includes: Point.h ";

%feature("docstring")  dolfin::Point::Point "

Create a point at (x, y, z). ";

%feature("docstring")  dolfin::Point::~Point "

Destructor. ";

%feature("docstring")  dolfin::Point::x "

Return x-coordinate. ";

%feature("docstring")  dolfin::Point::y "

Return y-coordinate. ";

%feature("docstring")  dolfin::Point::z "

Return z-coordinate. ";

%feature("docstring")  dolfin::Point::distance "

Compute distance to given point. ";

%feature("docstring")  dolfin::Point::norm "

Compute norm of point representing a vector from the origin. ";

%feature("docstring")  dolfin::Point::cross "

Compute cross product with given vector. ";

%feature("docstring")  dolfin::Point::dot "

Compute dot product with given vector. ";


// File: classdolfin_1_1Progress.xml
%feature("docstring") dolfin::Progress "

This class provides a simple way to create and update progress bars
during a computation. A progress bar may be used either in an
iteration with a known number of steps:

Progress p(\"Iterating...\", n); for (int i = 0; i < n; i++) { ...
p++; }

or in an iteration with an unknown number of steps:

Progress p(\"Iterating...\"); while (t < T) { ... p = t / T; }

C++ includes: Progress.h ";

%feature("docstring")  dolfin::Progress::Progress "

Create progress bar with a known number of steps. ";

%feature("docstring")  dolfin::Progress::Progress "

Create progress bar with an unknown number of steps. ";

%feature("docstring")  dolfin::Progress::~Progress "

Destructor. ";


// File: classdolfin_1_1Quadrature.xml
%feature("docstring") dolfin::Quadrature "";

%feature("docstring")  dolfin::Quadrature::Quadrature "

Constructor. ";

%feature("docstring")  dolfin::Quadrature::~Quadrature "

Destructor. ";

%feature("docstring")  dolfin::Quadrature::size "

Return number of quadrature points. ";

%feature("docstring")  dolfin::Quadrature::point "

Return quadrature point. ";

%feature("docstring")  dolfin::Quadrature::weight "

Return quadrature weight. ";

%feature("docstring")  dolfin::Quadrature::measure "

Return sum of weights (length, area, volume). ";

%feature("docstring")  dolfin::Quadrature::disp "

Display quadrature data. ";


// File: classdolfin_1_1RadauQuadrature.xml
%feature("docstring") dolfin::RadauQuadrature "

Radau (Gauss-Radau) quadrature on the interval [-1,1]. The n
quadrature points are given by the zeros of

( Pn-1(x) + Pn(x) ) / (1+x)

where Pn is the n:th Legendre polynomial.

The quadrature points are computed using Newton's method, and the
quadrature weights are computed by solving a linear system determined
by the condition that Radau quadrature with n points should be exact
for polynomials of degree 2n-2.

C++ includes: RadauQuadrature.h ";

%feature("docstring")  dolfin::RadauQuadrature::RadauQuadrature "";

%feature("docstring")  dolfin::RadauQuadrature::disp "

Display quadrature data. ";


// File: classdolfin_1_1Scalar.xml
%feature("docstring") dolfin::Scalar "

This class represents a real-valued scalar quantity and implements the
GenericTensor interface for scalars.

C++ includes: Scalar.h ";

%feature("docstring")  dolfin::Scalar::Scalar "

Constructor. ";

%feature("docstring")  dolfin::Scalar::~Scalar "

Destructor. ";

%feature("docstring")  dolfin::Scalar::init "

--- Implementation of GenericTensor interface ---

Initialize zero tensor of given rank and dimensions ";

%feature("docstring")  dolfin::Scalar::init "

Initialize zero tensor using sparsity pattern. ";

%feature("docstring")  dolfin::Scalar::create "

Create uninitialized scalar. ";

%feature("docstring")  dolfin::Scalar::copy "

Create copy of scalar. ";

%feature("docstring")  dolfin::Scalar::rank "

Return rank of tensor (number of dimensions). ";

%feature("docstring")  dolfin::Scalar::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::Scalar::get "

Get block of values. ";

%feature("docstring")  dolfin::Scalar::set "

Set block of values. ";

%feature("docstring")  dolfin::Scalar::add "

Add block of values. ";

%feature("docstring")  dolfin::Scalar::zero "

Set all entries to zero and keep any sparse structure (implemented by
sub class). ";

%feature("docstring")  dolfin::Scalar::apply "

Finalise assembly of tensor. ";

%feature("docstring")  dolfin::Scalar::disp "

Display tensor. ";

%feature("docstring")  dolfin::Scalar::getval "

Get value (needed for SWIG interface). ";

%feature("docstring")  dolfin::Scalar::factory "

Return a factory for the default linear algebra backend. ";


// File: classdolfin_1_1simple__array.xml
%feature("docstring") dolfin::simple_array "

The array class is a minimal wrapper for an array that knows its own
size. It is not yet another array class; it is only intended to be
used to pass data through the SWIG generated interface. Note that
users of this class are always responsible for allocating and
deallocating data.

C++ includes: simple_array.h ";

%feature("docstring")  dolfin::simple_array::simple_array "

Constructor. ";

%feature("docstring")  dolfin::simple_array::simple_array "

Destructor. ";


// File: classdolfin_1_1SparsityPattern.xml
%feature("docstring") dolfin::SparsityPattern "

This class represents the sparsity pattern of a vector/matrix. It can
be used to initalise vectors and sparse matrices. It must be
initialised before use.

C++ includes: SparsityPattern.h ";

%feature("docstring")  dolfin::SparsityPattern::SparsityPattern "

Constructor. ";

%feature("docstring")  dolfin::SparsityPattern::~SparsityPattern "

Destructor. ";

%feature("docstring")  dolfin::SparsityPattern::init "

Initialise sparsity pattern for a matrix with total number of rows and
columns. ";

%feature("docstring")  dolfin::SparsityPattern::pinit "

Initialise sparsity pattern for a parallel matrix with total number of
rows and columns. ";

%feature("docstring")  dolfin::SparsityPattern::insert "

Insert non-zero entry. ";

%feature("docstring")  dolfin::SparsityPattern::pinsert "

Insert non-zero entry for parallel matrices. ";

%feature("docstring")  dolfin::SparsityPattern::size "

Return global size. ";

%feature("docstring")  dolfin::SparsityPattern::numNonZeroPerRow "

Return array with number of non-zeroes per row. ";

%feature("docstring")  dolfin::SparsityPattern::numNonZeroPerRow "

Return array with number of non-zeroes per row diagonal and
offdiagonal for process_number. ";

%feature("docstring")  dolfin::SparsityPattern::numNonZero "

Return total number of non-zeroes. ";

%feature("docstring")  dolfin::SparsityPattern::pattern "

Return underlying sparsity pattern. ";

%feature("docstring")  dolfin::SparsityPattern::disp "

Display sparsity pattern. ";

%feature("docstring")  dolfin::SparsityPattern::apply "

Finalize sparsity pattern (needed by most parallel la backends). ";

%feature("docstring")  dolfin::SparsityPattern::processRange "

Return array with row range for process_number. ";

%feature("docstring")  dolfin::SparsityPattern::numLocalRows "

Return number of local rows for process_number. ";


// File: classstd_1_1vector.xml
%feature("docstring") std::vector "";


// File: classdolfin_1_1SubDomain.xml
%feature("docstring") dolfin::SubDomain "

This class defines the interface for definition of sub domains.
Alternatively, sub domains may be defined by a Mesh and a
MeshFunction<uint> over the mesh.

C++ includes: SubDomain.h ";

%feature("docstring")  dolfin::SubDomain::SubDomain "

Constructor. ";

%feature("docstring")  dolfin::SubDomain::~SubDomain "

Destructor. ";

%feature("docstring")  dolfin::SubDomain::inside "

Return true for points inside the sub domain (used for subclassing
through SWIG interface). ";

%feature("docstring")  dolfin::SubDomain::inside "

Return true for points inside the sub domain. ";

%feature("docstring")  dolfin::SubDomain::map "

Map coordinate x in domain H to coordinate y in domain G (used for
subclassing through SWIG interface). ";

%feature("docstring")  dolfin::SubDomain::map "

Map coordinate x in domain H to coordinate y in domain G (used for
periodic boundary conditions). ";

%feature("docstring")  dolfin::SubDomain::mark "

Set sub domain markers for given sub domain. ";


// File: classdolfin_1_1SubSystem.xml
%feature("docstring") dolfin::SubSystem "

This class represents a sub system that may be specified as a
recursively nested sub system of some given system.

The sub system is specified by an array of indices. For example, the
array [3, 0, 2] specifies sub system 2 of sub system 0 of sub system
3.

C++ includes: SubSystem.h ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Create empty sub system (no sub systems). ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Create given sub system (one level). ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Create given sub sub system (two levels). ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Create sub system for given array (n levels). ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Copy constructor. ";

%feature("docstring")  dolfin::SubSystem::depth "

Return number of levels for nested sub system. ";

%feature("docstring")  dolfin::SubSystem::extractFiniteElement "

Extract sub finite element of given finite element. ";

%feature("docstring")  dolfin::SubSystem::array "

Return array which defines sub system. ";


// File: classdolfin_1_1TimeDependent.xml
%feature("docstring") dolfin::TimeDependent "

Associates an object with time t.

C++ includes: TimeDependent.h ";

%feature("docstring")  dolfin::TimeDependent::TimeDependent "

Constructors. ";

%feature("docstring")  dolfin::TimeDependent::TimeDependent "";

%feature("docstring")  dolfin::TimeDependent::~TimeDependent "

Destructor. ";

%feature("docstring")  dolfin::TimeDependent::sync "

Associate object with time t. ";

%feature("docstring")  dolfin::TimeDependent::time "

Return the current time t. ";


// File: classublas__dense__matrix.xml
%feature("docstring") ublas_dense_matrix "";


// File: classdolfin_1_1uBlasFactory.xml
%feature("docstring") dolfin::uBlasFactory "";

%feature("docstring")  dolfin::uBlasFactory::~uBlasFactory "

Destructor. ";

%feature("docstring")  dolfin::uBlasFactory::createMatrix "

Create empty matrix. ";

%feature("docstring")  dolfin::uBlasFactory::createPattern "

Create empty sparsity pattern. ";

%feature("docstring")  dolfin::uBlasFactory::createVector "

Create empty vector. ";


// File: classdolfin_1_1uBlasKrylovSolver.xml
%feature("docstring") dolfin::uBlasKrylovSolver "

This class implements Krylov methods for linear systems of the form Ax
= b using uBlas data types.

C++ includes: uBlasKrylovSolver.h ";

%feature("docstring")  dolfin::uBlasKrylovSolver::uBlasKrylovSolver "

Create Krylov solver for a particular method and preconditioner. ";

%feature("docstring")  dolfin::uBlasKrylovSolver::uBlasKrylovSolver "

Create Krylov solver for a particular preconditioner (set by name). ";

%feature("docstring")  dolfin::uBlasKrylovSolver::uBlasKrylovSolver "

Create Krylov solver for a particular uBlasPreconditioner. ";

%feature("docstring")  dolfin::uBlasKrylovSolver::uBlasKrylovSolver "

Create Krylov solver for a particular method and uBlasPreconditioner.
";

%feature("docstring")  dolfin::uBlasKrylovSolver::~uBlasKrylovSolver "

Destructor. ";

%feature("docstring")  dolfin::uBlasKrylovSolver::solve "

Solve linear system Ax = b and return number of iterations (dense
matrix). ";

%feature("docstring")  dolfin::uBlasKrylovSolver::solve "

Solve linear system Ax = b and return number of iterations (sparse
matrix). ";

%feature("docstring")  dolfin::uBlasKrylovSolver::solve "

Solve linear system Ax = b and return number of iterations (virtual
matrix). ";


// File: classdolfin_1_1uBlasLinearSolver.xml
%feature("docstring") dolfin::uBlasLinearSolver "

This class defines the interfaces for uBlas-based linear solvers for
systems of the form Ax = b.

C++ includes: uBlasLinearSolver.h ";

%feature("docstring")  dolfin::uBlasLinearSolver::uBlasLinearSolver "

Constructor. ";

%feature("docstring")  dolfin::uBlasLinearSolver::~uBlasLinearSolver "

Destructor. ";

%feature("docstring")  dolfin::uBlasLinearSolver::solve "

Solve linear system Ax = b (A is dense). ";

%feature("docstring")  dolfin::uBlasLinearSolver::solve "

Solve linear system Ax = b (A is sparse). ";


// File: classdolfin_1_1uBlasLUSolver.xml
%feature("docstring") dolfin::uBlasLUSolver "

This class implements the direct solution ( LU factorization) of
linear systems of the form Ax = b using uBlas data types. Dense
matrices are solved using uBlas LU factorisation, and sparse matrices
are solved using UMFPACK
(http://www.cise.ufl.edu/research/sparse/umfpack/) is installed.
Matrices can also be inverted.

C++ includes: uBlasLUSolver.h ";

%feature("docstring")  dolfin::uBlasLUSolver::uBlasLUSolver "

Constructor. ";

%feature("docstring")  dolfin::uBlasLUSolver::~uBlasLUSolver "

Destructor. ";

%feature("docstring")  dolfin::uBlasLUSolver::solve "

Solve linear system Ax = b for a dense matrix. ";

%feature("docstring")  dolfin::uBlasLUSolver::solve "

Solve linear system Ax = b for a sparse matrix using UMFPACK if
installed. ";

%feature("docstring")  dolfin::uBlasLUSolver::solve "

Solve linear system Ax = b for a Krylov matrix. ";

%feature("docstring")  dolfin::uBlasLUSolver::solveInPlaceUBlas "

Solve linear system Ax = b in place (A is dense). ";

%feature("docstring")  dolfin::uBlasLUSolver::invert "

Compute the inverse of A (A is dense or sparse). ";


// File: classdolfin_1_1uBlasMatrix.xml
%feature("docstring") dolfin::uBlasMatrix "

Developer note: specialised member functions must be inlined to avoid
link errors.

This class represents a matrix (dense or sparse) of dimension M x N.
It is a wrapper for a Boost uBLAS matrix of type Mat.

The interface is intended to provide uniformity with respect to other
matrix data types. For advanced usage, refer to the documentation for
uBLAS which can be found
athttp://www.boost.org/libs/numeric/ublas/doc/index.htm.

C++ includes: uBlasMatrix.h ";

%feature("docstring")  dolfin::uBlasMatrix::uBlasMatrix "

Constructor. ";

%feature("docstring")  dolfin::uBlasMatrix::uBlasMatrix "

Constructor. ";

%feature("docstring")  dolfin::uBlasMatrix::uBlasMatrix "

Constructor from a uBlas matrix_expression. ";

%feature("docstring")  dolfin::uBlasMatrix::~uBlasMatrix "

Destructor. ";

%feature("docstring")  dolfin::uBlasMatrix::size "

Return number of rows (dim = 0) or columns (dim = 1). ";

%feature("docstring")  dolfin::uBlasMatrix::set "

Set block of values. ";

%feature("docstring")  dolfin::uBlasMatrix::add "

Add block of values. ";

%feature("docstring")  dolfin::uBlasMatrix::getRow "

Get non-zero values of row i. ";

%feature("docstring")  dolfin::uBlasMatrix::get "

Get block of values. ";

%feature("docstring")  dolfin::uBlasMatrix::lump "

Lump matrix into vector m. ";

%feature("docstring")  dolfin::uBlasMatrix::solve "

Solve Ax = b out-of-place (A is not destroyed). ";

%feature("docstring")  dolfin::uBlasMatrix::invert "

Compute inverse of matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::apply "

Apply changes to matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::zero "

Set all entries to zero. ";

%feature("docstring")  dolfin::uBlasMatrix::ident "

Set given rows to identity matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::mult "

Compute product y = Ax. ";

%feature("docstring")  dolfin::uBlasMatrix::compress "

Compress matrix (eliminate all non-zeros from a sparse matrix). ";

%feature("docstring")  dolfin::uBlasMatrix::disp "

Display matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::init "

Initialize M x N matrix.

The below functions have specialisations for particular matrix types.
In order to link correctly, they must be made inline functions. ";

%feature("docstring")  dolfin::uBlasMatrix::init "

Initialize a matrix from the sparsity pattern. ";

%feature("docstring")  dolfin::uBlasMatrix::create "

Create uninitialized matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::copy "

Create copy of matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::factory "

Get LA backend factory. ";


// File: classdolfin_1_1uBlasVector.xml
%feature("docstring") dolfin::uBlasVector "

This class represents a dense vector of dimension N. It is a simple
wrapper for a Boost ublas vector.

The interface is intentionally simple. For advanced usage, refer to
the documentation for ublas which can be found
athttp://www.boost.org/libs/numeric/ublas/doc/index.htm.

C++ includes: uBlasVector.h ";

%feature("docstring")  dolfin::uBlasVector::uBlasVector "

Constructor. ";

%feature("docstring")  dolfin::uBlasVector::uBlasVector "

Constructor. ";

%feature("docstring")  dolfin::uBlasVector::uBlasVector "

Constructor from a uBlas vector_expression. ";

%feature("docstring")  dolfin::uBlasVector::~uBlasVector "

Destructor. ";

%feature("docstring")  dolfin::uBlasVector::init "

Initialize a vector of length N. ";

%feature("docstring")  dolfin::uBlasVector::create "

Create uninitialized vector. ";

%feature("docstring")  dolfin::uBlasVector::copy "

Create copy of vector. ";

%feature("docstring")  dolfin::uBlasVector::size "

Return size. ";

%feature("docstring")  dolfin::uBlasVector::get "

Get values. ";

%feature("docstring")  dolfin::uBlasVector::set "

Set values. ";

%feature("docstring")  dolfin::uBlasVector::add "

Add values. ";

%feature("docstring")  dolfin::uBlasVector::get "

Get block of values. ";

%feature("docstring")  dolfin::uBlasVector::set "

Set block of values. ";

%feature("docstring")  dolfin::uBlasVector::add "

Add block of values. ";

%feature("docstring")  dolfin::uBlasVector::apply "

Apply changes to vector (dummy function for compatibility). ";

%feature("docstring")  dolfin::uBlasVector::zero "

Set all entries to zero. ";

%feature("docstring")  dolfin::uBlasVector::norm "

Compute norm of vector. ";

%feature("docstring")  dolfin::uBlasVector::sum "

Compute sum of vector. ";

%feature("docstring")  dolfin::uBlasVector::axpy "

Addition (AXPY). ";

%feature("docstring")  dolfin::uBlasVector::mult "

Scalar multiplication. ";

%feature("docstring")  dolfin::uBlasVector::div "

Element-wise division. ";

%feature("docstring")  dolfin::uBlasVector::disp "

Display vector. ";

%feature("docstring")  dolfin::uBlasVector::factory "

Return backend factory. ";

%feature("docstring")  dolfin::uBlasVector::copy "";


// File: classdolfin_1_1UndirectedClique.xml
%feature("docstring") dolfin::UndirectedClique "

A undirected graph where all vertices are adjacent to each other. The
number of vertices is given by num_vertices >= 1. The number of edges
is given by ((num_vertices - 1) * num_vertices) / 2

C++ includes: UndirectedClique.h ";

%feature("docstring")  dolfin::UndirectedClique::UndirectedClique "";


// File: classdolfin_1_1UnitCube.xml
%feature("docstring") dolfin::UnitCube "

Tetrahedral mesh of the 3D unit cube (0,1) x (0,1) x (0,1). Given the
number of cells (nx, ny, nz) in each direction, the total number of
tetrahedra will be 6*nx*ny*nz and the total number of vertices will be
(nx + 1)*(ny + 1)*(nz + 1).

C++ includes: UnitCube.h ";

%feature("docstring")  dolfin::UnitCube::UnitCube "";


// File: classdolfin_1_1UnitInterval.xml
%feature("docstring") dolfin::UnitInterval "

Interval mesh of the 1D unit line (0,1). Given the number of cells
(nx) in the axial direction, the total number of intervals will be nx
and the total number of vertices will be (nx + 1).

C++ includes: UnitInterval.h ";

%feature("docstring")  dolfin::UnitInterval::UnitInterval "";


// File: classdolfin_1_1UnitSquare.xml
%feature("docstring") dolfin::UnitSquare "

Triangular mesh of the 2D unit square (0,1) x (0,1). Given the number
of cells (nx, ny) in each direction, the total number of triangles
will be 2*nx*ny and the total number of vertices will be (nx + 1)*(ny
+ 1). The Type is an enumerater taking values in {left, right or
crisscross} indicating the direction of the diagonals for left/right
or both == crisscross. The default is right.

C++ includes: UnitSquare.h ";

%feature("docstring")  dolfin::UnitSquare::UnitSquare "";


// File: classdolfin_1_1Variable.xml
%feature("docstring") dolfin::Variable "";

%feature("docstring")  dolfin::Variable::Variable "";

%feature("docstring")  dolfin::Variable::Variable "";

%feature("docstring")  dolfin::Variable::Variable "";

%feature("docstring")  dolfin::Variable::rename "";

%feature("docstring")  dolfin::Variable::name "";

%feature("docstring")  dolfin::Variable::label "";


// File: classdolfin_1_1Vector.xml
%feature("docstring") dolfin::Vector "

This class provides an interface to the default DOLFIN vector
implementation as decided in default_la_types.h.

C++ includes: Vector.h ";

%feature("docstring")  dolfin::Vector::Vector "

Constructor. ";

%feature("docstring")  dolfin::Vector::Vector "

Constructor. ";

%feature("docstring")  dolfin::Vector::~Vector "

Destructor. ";

%feature("docstring")  dolfin::Vector::init "

Initialize vector of size N. ";

%feature("docstring")  dolfin::Vector::create "

Create uninitialized vector. ";

%feature("docstring")  dolfin::Vector::copy "

Create copy of vector. ";

%feature("docstring")  dolfin::Vector::size "

Return size. ";

%feature("docstring")  dolfin::Vector::get "

Get values. ";

%feature("docstring")  dolfin::Vector::set "

Set values. ";

%feature("docstring")  dolfin::Vector::add "

Add values. ";

%feature("docstring")  dolfin::Vector::get "

Get block of values. ";

%feature("docstring")  dolfin::Vector::set "

Set block of values. ";

%feature("docstring")  dolfin::Vector::add "

Add block of values. ";

%feature("docstring")  dolfin::Vector::zero "

Set all entries to zero. ";

%feature("docstring")  dolfin::Vector::apply "

Apply changes to matrix. ";

%feature("docstring")  dolfin::Vector::disp "

Display matrix (sparse output is default). ";

%feature("docstring")  dolfin::Vector::norm "

Compute norm of vector. ";

%feature("docstring")  dolfin::Vector::vec "

Return const implementation. ";

%feature("docstring")  dolfin::Vector::vec "

Return implementation. ";

%feature("docstring")  dolfin::Vector::factory "

Return backend factory. ";


// File: classdolfin_1_1Vertex.xml
%feature("docstring") dolfin::Vertex "

A Vertex is a MeshEntity of topological dimension 0.

C++ includes: Vertex.h ";

%feature("docstring")  dolfin::Vertex::Vertex "

Create vertex on given mesh. ";

%feature("docstring")  dolfin::Vertex::Vertex "

Create vertex from mesh entity. ";

%feature("docstring")  dolfin::Vertex::~Vertex "

Destructor. ";

%feature("docstring")  dolfin::Vertex::x "

Return value of vertex coordinate i. ";

%feature("docstring")  dolfin::Vertex::point "

Return vertex coordinates as a 3D point value. ";

%feature("docstring")  dolfin::Vertex::x "

Return array of vertex coordinates. ";

%feature("docstring")  dolfin::Vertex::x "

Return array of vertex coordinates. ";


// File: classdolfin_1_1VertexIterator.xml
%feature("docstring") dolfin::VertexIterator "

A VertexIterator is a MeshEntityIterator of topological dimension 0.

C++ includes: Vertex.h ";

%feature("docstring")  dolfin::VertexIterator::VertexIterator "";

%feature("docstring")  dolfin::VertexIterator::VertexIterator "";


// File: namespacedolfin.xml
%feature("docstring")  dolfin::tic "

Start timing. ";

%feature("docstring")  dolfin::toc "

Return elapsed time. ";

%feature("docstring")  dolfin::tocd "

Return and display elapsed time. ";

%feature("docstring")  dolfin::dolfin_get "

Get value of parameter with given key. ";

%feature("docstring")  dolfin::dolfin_set "

Set value of parameter. ";

%feature("docstring")  dolfin::dolfin_set "

Set special key/value pair. ";

%feature("docstring")  dolfin::dolfin_add "

Add parameter. ";

%feature("docstring")  dolfin::message "

Print message.

The DOLFIN log system provides the following set of functions for
uniform handling of log messages, warnings and errors. In addition,
macros are provided for debug messages and assertions.

Only messages with a debug level higher than or equal to the global
debug level are printed (the default being zero). The global debug
level may be controlled by

set(\"debug level\", debug_level);

where debug_level is the desired debug level.

The output destination can be controlled by

set(\"output destination\", destination);

where destination is one of \"terminal\" (default) or \"silent\".
Setting the output destination to \"silent\" means no messages will be
printed. ";

%feature("docstring")  dolfin::message "

Print message. ";

%feature("docstring")  dolfin::warning "

Print warning. ";

%feature("docstring")  dolfin::error "

Print error message and throw an exception. ";

%feature("docstring")  dolfin::begin "

Begin task (increase indentation level). ";

%feature("docstring")  dolfin::begin "

Begin task (increase indentation level). ";

%feature("docstring")  dolfin::end "

End task (decrease indentation level). ";

%feature("docstring")  dolfin::__debug "";

%feature("docstring")  dolfin::__dolfin_assert "";

%feature("docstring")  dolfin::solve "

Solve linear system Ax = b.

Solve linear system Ax = b using a direct method ( LU factorization).
Note that iterative methods (preconditioned Krylov methods including
GMRES) are also available through the KrylovSolver interface. ";

%feature("docstring")  dolfin::residual "

Compute residual ||Ax - b||. ";

%feature("docstring")  dolfin::dolfin_init "

Initialize DOLFIN (and PETSc) with command-line arguments. This should
not be needed in most cases since the initialization is otherwise
handled automatically. ";

%feature("docstring")  dolfin::sqr "

Return the square of x. ";

%feature("docstring")  dolfin::ipow "

Return a to the power n. ";

%feature("docstring")  dolfin::rand "

Return a random number, uniformly distributed between [0.0, 1.0). ";

%feature("docstring")  dolfin::seed "

Seed random number generator. ";

%feature("docstring")  dolfin::assemble "

Assemble tensor from given variational form and mesh.

These functions provide automated assembly of linear systems, or more
generally, assembly of a sparse tensor from a given variational form.
If you need to assemble a system more than once, consider using the
Assembler class, which may improve performance by reuse of data
structures. ";

%feature("docstring")  dolfin::assemble "

Assemble tensor from given variational form and mesh over a sub
domain. ";

%feature("docstring")  dolfin::assemble "

Assemble tensor from given variational form and mesh over sub domains.
";

%feature("docstring")  dolfin::assemble "

Assemble scalar from given variational form and mesh. ";

%feature("docstring")  dolfin::assemble "

Assemble scalar from given variational form and mesh over a sub
domain. ";

%feature("docstring")  dolfin::assemble "

Assemble scalar from given variational form and mesh over sub domains.
";

%feature("docstring")  dolfin::assemble "

Assemble tensor from given (UFC) form, mesh, coefficients and sub
domains. ";


// File: Array_8h.xml


// File: List_8h.xml


// File: simple__array_8h.xml


// File: TimeDependent_8h.xml


// File: timing_8h.xml


// File: Variable_8h.xml


// File: ElementLibrary_8h.xml


// File: assemble_8h.xml


// File: Assembler_8h.xml


// File: BoundaryCondition_8h.xml


// File: DirichletBC_8h.xml


// File: DofMap_8h.xml


// File: DofMapSet_8h.xml


// File: Form_8h.xml


// File: pAssembler_8h.xml


// File: PeriodicBC_8h.xml


// File: SubSystem_8h.xml


// File: Function_8h.xml


// File: SpecialFunctions_8h.xml


// File: DirectedClique_8h.xml


// File: Graph_8h.xml


// File: GraphEditor_8h.xml


// File: GraphPartition_8h.xml


// File: UndirectedClique_8h.xml


// File: File_8h.xml


// File: GenericMatrix_8h.xml


// File: GenericSparsityPattern_8h.xml


// File: GenericTensor_8h.xml


// File: GenericVector_8h.xml


// File: GMRES_8h.xml


// File: KrylovMethod_8h.xml


// File: KrylovSolver_8h.xml


// File: LinearAlgebraFactory_8h.xml


// File: LinearSolver_8h.xml


// File: LU_8h.xml


// File: LUSolver_8h.xml


// File: Matrix_8h.xml


// File: PETScFactory_8h.xml


// File: PETScKrylovSolver_8h.xml


// File: PETScLinearSolver_8h.xml


// File: PETScLUSolver_8h.xml


// File: PETScMatrix_8h.xml


// File: PETScObject_8h.xml


// File: PETScVector_8h.xml


// File: Preconditioner_8h.xml


// File: Scalar_8h.xml


// File: SLEPcEigenvalueSolver_8h.xml


// File: solve_8h.xml


// File: SparsityPattern_8h.xml


// File: uBlasDenseMatrix_8h.xml


// File: uBlasFactory_8h.xml


// File: uBlasKrylovSolver_8h.xml


// File: uBlasLinearSolver_8h.xml


// File: uBlasLUSolver_8h.xml


// File: uBlasMatrix_8h.xml


// File: uBlasVector_8h.xml


// File: Vector_8h.xml


// File: Event_8h.xml


// File: log_8h.xml


// File: LogStream_8h.xml


// File: Progress_8h.xml


// File: constants_8h.xml


// File: init_8h.xml


// File: basic_8h.xml


// File: Lagrange_8h.xml


// File: Legendre_8h.xml


// File: BoundaryMesh_8h.xml


// File: Cell_8h.xml


// File: Edge_8h.xml


// File: Face_8h.xml


// File: Facet_8h.xml


// File: IntersectionDetector_8h.xml


// File: Mesh_8h.xml


// File: MeshConnectivity_8h.xml


// File: MeshEditor_8h.xml


// File: MeshEntity_8h.xml


// File: MeshEntityIterator_8h.xml


// File: MeshFunction_8h.xml


// File: MeshGeometry_8h.xml


// File: MeshTopology_8h.xml


// File: MPIMeshCommunicator_8h.xml


// File: Point_8h.xml


// File: SubDomain_8h.xml


// File: UnitCube_8h.xml


// File: UnitInterval_8h.xml


// File: UnitSquare_8h.xml


// File: Vertex_8h.xml


// File: MatrixFactory_8h.xml


// File: NewtonSolver_8h.xml


// File: NonlinearProblem_8h.xml


// File: cGqMethod_8h.xml


// File: ComplexODE_8h.xml


// File: dGqMethod_8h.xml


// File: Homotopy_8h.xml


// File: Method_8h.xml


// File: ODE_8h.xml


// File: Parameter_8h.xml


// File: parameters_8h.xml


// File: Parametrized_8h.xml


// File: LinearPDE_8h.xml


// File: NonlinearPDE_8h.xml


// File: GaussianQuadrature_8h.xml


// File: GaussQuadrature_8h.xml


// File: LobattoQuadrature_8h.xml


// File: Quadrature_8h.xml


// File: RadauQuadrature_8h.xml


// File: dir_b6f50706cb9714b448a6eb80737026a9.xml


// File: dir_2da428ad44f53dfe553da921dc9958db.xml


// File: dir_e1c7277e193fbd0adb23368c0e38bb75.xml


// File: dir_40220893e01e460d18509f097f94540d.xml


// File: dir_d1e2aef396b1a3e5b8fcb4aa5c24449c.xml


// File: dir_5f4fcd2bba542de4e226828392fdfa6e.xml


// File: dir_91ecf1529bbe7024b548c6fb7f0b27c0.xml


// File: dir_15c6e4422aec06179b9b60e889e09528.xml


// File: dir_531c39d775379704ed499baa9dcd4436.xml


// File: dir_56b9860eb883c4c158c65333cf55ea79.xml


// File: dir_82bacb5830a795738b7bccbfdf2ca737.xml


// File: dir_769ea50760d8bc5f3305f92ded7c16ba.xml


// File: dir_69898268e5df5b89dd84521bf0e385bb.xml


// File: dir_169eea683125e6c26f8526cf4daa7422.xml


// File: dir_5ec121423962ee8787737efa6f6421e4.xml


// File: dir_6d6c59dade9611e72e5d605ee8693670.xml


// File: dir_930b4bafb793a34e5823888263adb3f3.xml


// File: dir_d7703bdfa5748737b170136bd5963f04.xml


// File: dir_733a0def988b57d08a2a2817a30c611f.xml


// File: dir_b269bc3560f04f2b861fd291e35a8396.xml


// File: dir_ba8c5d58a5e682babe409bbf8d436d56.xml


// File: dir_4b8c1586a59038bab34cc078308378c1.xml


// File: dir_5181fc30b74596c127f02eb6380599f1.xml


// File: dir_2663a796a8bf0c5fc4c72a5516e654e2.xml


// File: dir_e7b96a461c41eff64e0b5d9505aa73b1.xml


// File: dir_afb2bc9dfd9657d8ddf4393cf30bdf65.xml


// File: dir_6000af6eef1afe780b3bba23fda3d89a.xml


// File: dir_95c5c65f39ef2792fc4865c83fd27db3.xml


// File: dir_d00be9c89d8f8aa90f29356b72b0c6a6.xml


// File: dir_a45f7652b6600b09ebddd098b5ce6e42.xml


// File: dir_7d01225e783771cb437686f8c4a31a5d.xml


// File: dir_617ebbb62e9ca71f8fb1a6afb144b9f3.xml


// File: dir_0edd2b5577f17de64d6dc96fdc2bcdbd.xml


// File: dir_c8dc3b8fff82d0eca9d61d998ba9168b.xml


// File: dir_5dc63f43beb5f8e3855237ab305c58ce.xml

