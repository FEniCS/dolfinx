# Test form for updated elasticity

from Numeric import *
from math import *

name = "ElasticityUpdatedJaumann"
element1 = FiniteElement("Vector Lagrange", "tetrahedron", 1)
element2 = FiniteElement("Discontinuous vector Lagrange", "tetrahedron", 0, 9)

q = BasisFunction(element2)
v = Function(element1)
sigma = Function(element2)

global zero
zero = 0.0 * Constant()

def ffczeros(m, n):
    A = array((zero))
    A = resize(A, (m, n))
    A *= 0.0
    
    return A

def ffcidentity(m):
    A = myzeros(m, m)

    for ii in range(m):
        for jj in range(m):
            if ii == jj:
                A[ii, jj] = 1.0
                    
    return A

def epsilon(u):
    eu = ffczeros(3, 3)

    for ii in range(3):
        for jj in range(3):
            eu[ii, jj] = 0.5 * (u[ii].dx(jj) + u[jj].dx(ii))

    return eu

def epsilonspin(u):
    eu = ffczeros(3, 3)

    for ii in range(3):
        for jj in range(3):
            eu[ii, jj] = 0.5 * (u[ii].dx(jj) - u[jj].dx(ii))

    return eu


def E(e, lmbda, mu):
    Ee = 2.0 * multiply(mu, e)
    for ii in range(3):
        for jj in range(3):
            if ii == jj:
                Ee[ii, jj] += lmbda * trace(e)

    return Ee

def tomatrix(q):
    qmatrix = ffczeros(3, 3)

    for ii in range(3):
        for jj in range(3):
            qmatrix[ii, jj] = q[3 * ii + jj];

    return qmatrix

qmatrix = tomatrix(q)
sigmamatrix = tomatrix(sigma)

D = epsilon(v)

W = epsilonspin(v)

A = ones((3, 3))

#Ljaumann = vdot(matrixmultiply(W, sigmamatrix) -
#	matrixmultiply(sigmamatrix, W), qmatrix)

Ljaumann = vdot(matrixmultiply(W, sigmamatrix) - matrixmultiply(sigmamatrix, W), qmatrix)

#Ljaumann = vdot(matrixmultiply(W, sigmamatrix), qmatrix)
#Ljaumann = vdot(matrixmultiply(W, A), qmatrix)

#Ljaumann = vdot(W, qmatrix)

#Ljaumann = (W[0, 0] * A[0, 0] +
#	 W[0, 1] * A[1, 0] +
#	W[0, 2] * A[2, 0]) * q[0]

#Ljaumann = (W[0, 0] * sigma[0] +
#	 W[0, 1] * sigma[1] +
#	W[0, 2] * sigma[2]) * q[0]

L = Ljaumann * dx
