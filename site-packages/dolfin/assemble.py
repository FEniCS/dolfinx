"""This module provides functionality for form assembly in Python,
corresponding to the C++ assembly and PDE classes.

The C++ assemble function (renamed to cpp_assemble) is wrapped with
an additional preprocessing step where code is generated using the
FFC JIT compiler.

The C++ PDE classes are reimplemented in Python since the C++ classes
rely on the dolfin::Form class which is not used on the Python side."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2007-08-15 -- 2008-08-06"
__copyright__ = "Copyright (C) 2007-2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

# Modified by Martin Sandve Alnaes, 2008
# Modified by Johan Hake, 2008

__all__ = ["assemble", "assemble_system", "compile_functions", "jit"]

from ffc import *
from dolfin import *
from compile_functions import compile_functions

# Cache for dof maps
_dof_map_cache = {}

# Cache for tensors
_tensor_cache = {}

# Temporary storage of compiled coefficient functions avoiding
# Python deleting our function objects before assembly!
_compiled_coefficients = []

# Add a parameter for form compiler
dolfin_add("form compiler", "ffc")

# JIT assembler
def assemble(form, mesh, coefficients=None, dof_maps=None,
    cell_domains=None, exterior_facet_domains=None, interior_facet_domains=None, reset_tensor=None,
    tensor=None, backend=None, return_dofmaps=False, form_compiler_options=None):
    "Assemble form over mesh and return tensor"

    # Check if we need to compile the form (JIT)
    if not hasattr(form, "create_cell_integral"):
        # FFC form, call JIT compile
        (compiled_form, module, form_data) = jit(form, form_compiler_options)
    else:    
        # UFC form, no need to compile
        compiled_form = form
        form_data     = None

    # Extract coefficients
    _coefficients = _extract_coefficients(coefficients, form_data, mesh)

    # Create dof map set
    dof_maps = _create_dof_map_set(form, compiled_form, mesh, dof_maps)

    # Create tensor
    rank = compiled_form.rank()
    (tensor, reset_tensor) = _create_tensor(form, rank, backend, tensor, reset_tensor)

    # Set default value for reset_tensor if not specified
    if reset_tensor is None:
        reset_tensor = True

    # Assemble tensor from compiled form
    cpp_assemble(tensor, compiled_form, mesh, _coefficients, dof_maps,
                 cell_domains, exterior_facet_domains, interior_facet_domains, reset_tensor)

    # Clear any temporary stored coeffisient functions
    _clear_compiled_coefficients()

    # Convert to float for scalars
    if rank == 0:
        tensor = tensor.getval()
    
    # Return value
    if return_dofmaps:
        return tensor, dof_maps
    else:
        return tensor


# JIT system assembler
def assemble_system(A_form, b_form, bcs, mesh, x0=None, A_coefficients=None, b_coefficients=None, A_dof_maps=None, b_dof_maps=None,
    cell_domains=None, exterior_facet_domains=None, interior_facet_domains=None, reset_tensor=None,
    A_tensor=None, b_tensor=None, backend=None, return_dofmaps=False, form_compiler_options=None):
    "Assemble form over mesh and return tensor"

    # Check if we need to compile the A_form (JIT)
    if not hasattr(A_form, "create_cell_integral"):
        # FFC form, call JIT compile
        (A_compiled_form, module, A_form_data) = jit(A_form, form_compiler_options)
    else:    
        # UFC form, no need to compile
        compiled_form = form
        A_form_data     = None

    # Check if we need to compile the b_form (JIT)
    if not hasattr(b_form, "create_cell_integral"):
        # FFC form, call JIT compile
        (b_compiled_form, module, b_form_data) = jit(b_form, form_compiler_options)
    else:    
        # UFC form, no need to compile
        compiled_form = form
        b_form_data     = None

    # Extract coefficients
    _A_coefficients = _extract_coefficients(A_coefficients, A_form_data, mesh)
    _b_coefficients = _extract_coefficients(b_coefficients, b_form_data, mesh)

    # Create dof map set
    A_dof_maps = _create_dof_map_set(A_form, A_compiled_form, mesh, A_dof_maps)
    b_dof_maps = _create_dof_map_set(b_form, b_compiled_form, mesh, b_dof_maps)

    # Create tensor
    rank = A_compiled_form.rank()
    (A_tensor, reset_tensor) = _create_tensor(A_form, rank, backend, A_tensor, reset_tensor)
    rank = b_compiled_form.rank()
    (b_tensor, reset_tensor) = _create_tensor(b_form, rank, backend, b_tensor, reset_tensor)

    # Set default value for reset_tensor if not specified
    if reset_tensor is None:
        reset_tensor = True

    # Make sure we have a list
    if not isinstance(bcs, list):
      bcs = [bcs]

    bc_array = ArrayDirichletBCPtr()
    for bc in bcs:
        bc_array.push_back(bc)

    # Assemble tensor from compiled form
    cpp_assemble_system(A_tensor, A_compiled_form, _A_coefficients, A_dof_maps,  
                        b_tensor, b_compiled_form, _b_coefficients, b_dof_maps,  
                        x0, mesh, bc_array, 
                        cell_domains, exterior_facet_domains, interior_facet_domains, reset_tensor)
    
    # Clear any temporary stored coeffisient functions
    _clear_compiled_coefficients()
    
    # Return value
    if return_dofmaps:
        return A_tensor, A_dof_maps, b_tensor, b_dof_maps
    else:
        return A_tensor, b_tensor


def _create_dof_map_set(form, compiled_form, mesh, dof_maps):
    "Create dof map set for form"

    # Check if dof map set is supplied by user
    if dof_maps:
        return dof_maps

    # Check if we should use the cache
    use_cache = dolfin_get("optimize use dof map cache") or dolfin_get("optimize")
    if use_cache and form in _dof_map_cache:
        return _dof_map_cache[form]

    # Create dof map set
    dof_maps = DofMapSet(compiled_form, mesh)

    # Store in cache
    if use_cache:
        _dof_map_cache[form] = dof_maps

    return dof_maps

def jit(form, options = None):
    """Just-in-time compile any provided form

    It uses the jit function from the form compiler registered by
    dolfin_set("form compiler")
    """

    # Import the form compiler
    compiler_str = dolfin_get("form compiler")
    try:
        fc = __import__(compiler_str)
    except ImportError:
        raise RuntimeError, "Could not import %s form compiler" % compiler_str
    
    # Get jit function
    try:
        jit_compile = fc.jit
    except AttributeError:
        raise RuntimeError, "Form compiler must implement the jit function"
    
    # FIXME: This options stuff is FFC specific, sort of destroys the purpose of this function...
    #        Global FFC options should be set in FFC, not DOLFIN!
    if options is None:
        options = {}
    options["cpp optimize"] = dolfin_get("optimize form") or dolfin_get("optimize")
    
    return jit_compile(form, options)

def _extract_coefficients(coefficients, form_data, mesh):
    "Extract provided coefficients"
    
    # Create empty list of coefficients, filled below
    _coefficients = ArrayFunctionPtr()
    
    # Extract coefficients
    if coefficients is None:
        # If no coefficients are porvided try to extract them from form_data
        if hasattr(form_data,"coefficients"):
            for c in form_data.coefficients:
                _coefficients.push_back(c.f)
    else:
        # Compile all strings as dolfin::Function
        string_expressions = []
        for c in coefficients:
            # Note: To allow tuples of floats or ints below, this logic becomes more involved...
            if isinstance(c, (tuple, str)):
                string_expressions.append(c)
        if string_expressions:
            compiled_functions = compile_functions(string_expressions, mesh)
            compiled_functions.reverse()
        
        # Build list of coefficients
        for c in coefficients:
            # Note: We could generalize this to support more objects 
            # like sympy expressions, tuples for constant vectors, etc...
            if isinstance(c, (float, int)):
                c = cpp_Function(mesh, float(c))
            elif isinstance(c, (tuple, str)):
                c = compiled_functions.pop()
            _coefficients.push_back(c)
            _compiled_coefficients.append(c)

    return _coefficients

def _clear_compiled_coefficients():
    "Clear stored compiled coeffisient functions" 
    while _compiled_coefficients:
        _compiled_coefficients.pop()

def _create_tensor(form, rank, backend, tensor, reset_tensor):
    "Create tensor for form"

    # Check if tensor is supplied by user
    if tensor:
        return (tensor, reset_tensor)

    # Decide if we should reset the tensor
    use_cache = dolfin_get("optimize use tensor cache") or dolfin_get("optimize")
    if use_cache and reset_tensor is None:
        reset_tensor = not form in _tensor_cache

    # Check if we should use the cache
    if use_cache and form in _tensor_cache:
        return (_tensor_cache[form], reset_tensor)

    # Create tensor
    if rank == 0:
        tensor = Scalar()
    elif rank == 1:
        if backend: tensor = backend.createVector()
        else:       tensor = Vector()
    elif rank == 2:
        if backend: tensor = backend.createMatrix()
        else:       tensor = Matrix()
    else:
        raise RuntimeError, "Unable to create tensors of rank %d." % rank

    # Store in cache
    if use_cache:
        _tensor_cache[form] = tensor

    return (tensor, reset_tensor)
