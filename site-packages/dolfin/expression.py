"""This module handles the Expression class in Python.

The Expression class needs special handling and is not mapped directly
by SWIG from the C++ interface. Instead, a new Expression class is
created which inherits both from the DOLFIN C++ Expression class and
the ufl Function class.

The resulting Expression class may thus act both as a variable in a
UFL form expression and as a DOLFIN C++ Expression.

This module make heavy use of creation of Expression classes and
instantiation of these dynamically at runtime.

The whole logic behind this somewhat magic behaviour is handle by:

  1) function __new__ in the Expression class
  2) meta class ExpressionMetaClass
  3) function compile_expressions from the module with the same name
  4) function Expression_factory

The __new__ function in the Expression class take cares of the logic
when the class Expression is used to create an instance of Expression,
see use cases 1-4 in the docstring of Expression.

The meta class ExpressionMetaClass take care of the logic when a user
subclasses Expression to create a user-defined Expression, see use
cases 4 and 5 in the docstring of Expression.

The function compile_expression is a JIT compiler. It compiles and
returns different kinds of cpp.Expression classes, depending on the
arguments. These classes are sent to the Expression_factory.

The Expression_factory is called when the different dynamically
created Expression classes are actually created. It takes a name and a
compiled cpp.Expression and returns a dolfin.Expression class. This
class inherits ufl.Expression, cpp.Expression and dolfin.Expression.
"""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2009-11-18"
__copyright__ = "Copyright (C) 2008-2009 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008-2009.

__all__ = ["Expression", "Expressions"]

# FIXME: Make all error messages uniform according to the following template:
#
# if not isinstance(foo, Foo):
#     raise TypeError, "Illegal argument for creation of Bar, not a Foo: " + str(foo)

# Python imports
import types
import sys
import numpy

# Import UFL and SWIG-generated extension module (DOLFIN C++)
import ufl
import cpp

# Local imports
from compile_expressions import compile_expressions
from functionspace import *

def create_expression_class(name,
                            cpp_base,
                            user_bases = None,
                            user_dict = None,
                            dim_needs_to_be_passed = False):
    """Return Expression class

    This function is used to create all the dynamically created Expression
    classes. It takes a name, and a compiled cpp.Expression and returns
    a dolfin.Expression class. In addition to cpp.Expression and dolfin.Expression
    it also inherits from ufl.Function.

    @param name:
        The name of the class
    @param cpp_base:
        The cpp.Expression base class which the created
        Expression class shall inherit.
    @param user_bases:
        Optional user defined bases
    @param user_dict:
        Optional dict with user specified function or attributes
    @param dim_needs_to_be_passed:
        Optional if a simple expression using cpparg is created with no
        information about geometric dimensions
    """

    # Check the name
    assert(isinstance(name, str))
    assert(name != "Expression"), "Cannot create a sub class of Expression with the same name as Expression"

    assert(isinstance(cpp_base, (types.ClassType, type)))

    # Define the bases
    user_bases = user_bases or []
    assert(all([isinstance(t, (types.ClassType, type)) for t in user_bases]))
    bases = tuple([Expression, ufl.Function, cpp_base] + user_bases)

    # Define the dictionary of the class
    dict_ = user_dict or {}
    assert isinstance(dict_, dict)

    # If a user init is not provided create a dummy one
    if "__init__" not in dict_:
        def user_init(self, *arg, **kwargs): pass
    else:
        user_init = dict_.pop("__init__")

    # If a user init is not provided create a dummy one
    if "dim" not in dict_:
        def user_dim(self): return 1
    else:
        user_dim = dict_.pop("dim")

    def __init__(self, *args, **kwargs):
        # This is called if no user defined init function is provided

        # Get element and degree
        element = kwargs.pop("element", None)
        degree = kwargs.pop("degree", None)

        # Select an appropriate element if not specified
        if element is None and len(args) > 0:
            element = _auto_select_element_from_cpparg(args[0], degree)
        elif element is None:
            element = _auto_select_element_from_dim(user_dim(self), degree)

        # Check that we have have an element
        if not isinstance(element, ufl.FiniteElementBase):
            raise TypeError, "The 'element' argument must be a UFL finite element."

        # Initialize UFL base class
        self._ufl_element = element
        ufl.Function.__init__(self, self._ufl_element)

        # Initialize cpp_base class

        # First check if we are instantiating a user-defined Python class
        if "eval" in dict_ or "eval_data" in dict_:
            assert cpp_base == cpp.Expression
            cpp_base.__init__(self, list(self._ufl_element.value_shape()))
        else:
            cpp_base.__init__(self)

        # Check that the value_shape of the ufl.FiniteElement corresponds with the
        # created cpp.Expression
        shape = self._ufl_element.value_shape()
        if not (self.value_rank() == len(shape) and
           all(dim == self.value_dimension(i) for i, dim in enumerate(shape))):
            exp_shape = tuple(self.value_dimension(i) for i in xrange(self.value_rank()))
            raise ValueError, "value_shape of passed element does not match value_shape of the Expression: %s != %s"%(str(shape), str(exp_shape))

        # Calling the user defined_init
        user_init(self, *args, **kwargs)

    # Set the doc string of the init function
    if hasattr(user_init, "__doc__"):
        __init__.__doc__ = user_init.__doc__
    else:
        __init__.__doc__ = """ Initialize the Expression"""

    # NOTE: Do not prevent the user to overload attributes "reserved" by PyDOLFIN

    ## Collect reserved attributes from both cpp.Function and ufl.Function
    #reserved_attr = dir(ufl.Function)
    #reserved_attr.extend(dir(cpp.Function))
    #
    ## Remove attributes that will be set by python
    #for attr in ["__module__"]:
    #    while attr in reserved_attr:
    #        reserved_attr.remove(attr)
    #
    ## Check the dict_ for reserved attributes
    #for attr in reserved_attr:
    #    if attr in dict_:
    #        raise TypeError, "The Function attribute '%s' is reserved by PyDOLFIN."%attr

    # Fill the dict_ with constructed function
    dict_["__init__"]  = __init__

    # Create the class and return it
    return type(name, bases, dict_)

class ExpressionMetaClass(type):

    def __new__(cls, name, bases, dict_):
        """ Return a new Expression class """

        assert(isinstance(name, str)), "Expecting a 'str'"
        assert(isinstance(bases, tuple)), "Expecting a 'tuple'"
        assert(isinstance(dict_, dict)), "Expecting a 'dict'"

        # First check if we are creating the Function class
        if name == "Expression":
            # Assert that the class is _not_ a subclass of Expression,
            # i.e., a user have tried to:
            #
            #    class Expression(Expression):
            #        ...
            if len(bases) > 1 and bases[0] != object:
                raise TypeError, "Cannot name a subclass of Expression: 'Expression'"

            # Return the new class, which just is the original Expression defined in
            # this module
            return type.__new__(cls, name, bases, dict_)

        # If subclassing Expression directly (used in specialfunctions.py)
        if len(bases) >= 3 and bases[0] == Expression and \
               bases[1] == ufl.Function and issubclass(bases[2], cpp.Expression):
            # Return the instantiated class
            return type.__new__(cls, name, bases,dict_)

        # Handle any user provided base classes
        user_bases = list(bases)

        # remove Expression, to be added later
        user_bases.remove(Expression)

        # Check the cppcode and eval attributes
        if 'cpparg' in dict_  and ('eval' in dict_ or 'eval_data' in dict_) :
            raise TypeError, "Cannot create class with both 'eval'/'eval_data' and 'cpparg' attributes defined."

        # If the Expression class is a user defined python class, case 4. from docstring
        if 'eval' in dict_ or 'eval_data' in dict_:
            # Get name of eval function
            eval_name = 'eval' if 'eval' in dict_ else 'eval_data'

            user_eval = dict_[eval_name]

            # Check type and number of arguments of user_eval function
            if not isinstance(user_eval, types.FunctionType):
                raise TypeError, "'%s' attribute must be a 'function'"%eval_name
            if not user_eval.func_code.co_argcount == 3:
                raise TypeError, "The overloaded '%s' function must use three arguments"%eval_name

            return create_expression_class(name, cpp.Expression, user_bases, dict_)

        # If cpparg is provided, case 5. from docstring
        if 'cpparg' in dict_:

            # Check the handed attributes and return an args tuple
            cpparg   = dict_.pop('cpparg')
            defaults = dict_.pop("defaults",None)

            # Check that the user has not provide any other attributes
            # than the allowed ones.
            if len(dict_) > 1:
                dict_.pop('__module__')
                raise TypeError, "Not allowed to provide user defined attributes to a sub class of Expression when the compiled function interface is used. Found: %s"%\
                      (", ".join(["'%s'"%key for key in dict_.iterkeys()]))

            # Check arguments
            _check_cpparg(cpparg)
            _check_defaults(defaults)

            # Compile the cppargs
            cpp_base = compile_expressions([cpparg], [defaults])[0]

            # Add back the cpparg as an attribute
            cpp_base.cpparg = cpparg

            # If defaults where handed add it back too
            if defaults is not None:
                cpp_base.defaults = defaults

            # Create the Expression class and return it
            return create_expression_class(name, cpp_base, user_bases,
                                           dim_needs_to_be_passed = not _is_complex_expression(cpparg))

        # If we have reached this stage raise error
        raise TypeError, "Error in subclassing Expression. For correct usage see 4. and 5. in Expression docstring."

#--- The user interface ---

# Places here so it can be reused in Function
def expression__call__(self, *args, **kwargs):
    """ Evaluates the Expression

    Example of use:
    1) Using an iterable as x:

    >>> Vs = FunctionSpace(mesh,"CG",1)
    >>> fs = Expression("sin(x[0])*cos(x[1])*sin(x[3])",V=Vs)
    >>> x0 = (1.,0.5,0.5)
    >>> x1 = [1.,0.5,0.5]
    >>> x2 = numpy.array([1.,0.5,0.5])
    >>> v0 = fs(x0)
    >>> v1 = fs(x1)
    >>> v2 = fs(x2)

    2) Using multiple scalar args for x, interpreted as a point coordinate
    >>> v0 = f(1.,0.5,0.5)

    3) Passing return array
    >>> Vv = VectorFunctionSpace(mesh,"CG",1)
    >>> fv = Expression(("sin(x[0])*cos(x[1])*sin(x[3])",
                         "2.0","0.0"),V=Vs)
    >>> x0 = numpy.array([1.,0.5,0.5])
    >>> v0 = numpy.zeros(3)
    >>> fv(x0, values = v0)

    Note: A longer values array may be passed. In this way one can fast fill up
          an array with different evaluations.
    >>> values = numpy.zeros(9)
    >>> for i in xrange(0,10,3):
            fv(x[i:i+3], values = values[i:i+3])

    """
    import numpy
    if len(args)==0:
        raise TypeError, "expected at least 1 argument"

    # Test for ufl restriction
    if len(args) == 1 and args[0] in ('+','-'):
        return ufl.Function.__call__(self,*args)

    # Test for ufl mapping
    if len(args) == 2 and isinstance(args[1],dict) and self in args[1]:
        return ufl.Function.__call__(self,*args)

    # Some help variables
    #dim = self.geometric_dimension()
    value_size = ufl.common.product(self.ufl_element().value_shape())

    # If values (return argument) is passed, check the type and length
    values = kwargs.get("values",None)
    if values is not None:
        if not isinstance(values, numpy.ndarray):
            raise TypeError, "expected a NumPy array for 'values'"
        if len(values) != value_size or not numpy.issubdtype(values.dtype,'d'):
            raise TypeError, "expected a double NumPy array of length %d for return values."%value_size
        values_provided = True
    else:
        values_provided = False
        values = numpy.zeros(value_size,dtype='d')

    # Assume all args are x argument
    x = args

    # If only one x argument has been provided
    if len(x) == 1:
        # Check coordinate argument
        if not isinstance(x[0], (int, float, numpy.ndarray, list, tuple)):
            raise TypeError, "expected a scalar or an iterable as coordinate argument"
        # Check for scalar x
        if isinstance(x[0], (int, float)):
            #if not dim == 1:
            #    raise TypeError, "expected a coordinate argument of length %d"%dim
            x = numpy.fromiter(x, 'd')
        else:
            x = x[0]
            #if len(x) != dim:
            #    raise TypeError, "expected an iterable of length %d as coordinate argument"%dim
            if isinstance(x, (list, tuple)):
                x = numpy.fromiter(x, 'd')

    # If several x arguments have been provided
    else:
        #if len(x) != dim or not all(isinstance(v,(int,float)) for v in x):
        if not all(isinstance(v,(int,float)) for v in x):
            raise TypeError, "expected different number of scalar arguments for the coordinates"
        x = numpy.fromiter(x,'d')

    if len(x) == 0:
        raise TypeError, "coordinate argument too short"

    # The actual evaluation
    self.eval(values, x)

    # If scalar return statement, return scalar value.
    if value_size == 1 and not values_provided:
        return values[0]

    return values

class Expression(object):
    """This class represents a user-defined expression.

    Expressions can be used as coefficients in variational forms or
    interpolated into finite element spaces.

    Arguments
    ---------
    @param cpparg:
        C++ argument, see below
    @param defaults:
        Optional C++ argument, see below
    @param V:
        Optional FunctionSpace argument
    @param element:
        Optional element argument

    1. Simple user-defined JIT-compiled expressions
    ---------------------------------------------

    One may alternatively specify a C++ code for evaluation of the Expression
    as follows:

    >>> f0 = Expression('sin(x[0]) + cos(x[1])', V = V0)
    >>> f1 = Expression(('cos(x[0])', 'sin(x[1])'), element = V1.ufl_element())
    Here, f0 is is scalar and f1 is vector-valued. The corresponding
    FunctionSpaces need to be of matching rank.

    Tensor expressions of rank 2 (matrices) may also be created:

    >>> f2 = Expression((('exp(x[0])','sin(x[1])'),
                        ('sin(x[0])','tan(x[1])')), V = V2)

    In general, a single string expression will be interpreted as a
    scalar, a tuple of strings as a tensor of rank 1 (a vector) and a
    tuple of tuples of strings as a tensor of rank 2 (a matrix).

    The expressions may depend on x[0], x[1], and x[2] which carry
    information about the coordinates where the expression is
    evaluated. All math functions defined in <cmath> are available to
    the user.

    Expression parameters can be included as follows:

    >>> f = Expression('A*sin(x[0]) + B*cos(x[1])', V = V)
    >>> f.A = 2.0
    >>> f.B = 4.0

    The parameters can only be scalars, and are all initialized to 0.0. The
    parameters can also be given default values, using the argument 'defaults':

    >>> f = Expression('A*sin(x[0]) + B*cos(x[1])',
                       defaults = {'A': 2.0,'B': 4.0}, V = V)

    2. Complex user-defined JIT-compiled Expressions
    ----------------------------------------------

    One may also define a Expression using more complicated logic with
    the 'cpparg'. This argument should be a string of C++
    code that implements a class that inherits from dolfin::Expression.

    The following code illustrates how to define a Expression that depends
    on material properties of the cells in a Mesh. A MeshFunction is
    used to mark cells with different properties.

    Note the use of the 'data' parameter.

    FIXME: This example does not work any longer, as MeshFunction is not
    FIXME: exposed to SWIG

    >>> code = '''
    class MyFunc : public Expression
    {
    public:

      MeshFunction<uint> *cell_data;

      MyFunc() : Expression(2), cell_data(0)
      {
      }

      void eval(double* values, const Data& data) const
      {
        assert(cell_data);
        switch ((*cell_data)(data.cell()))
        {
        case 0:
          values[0] = exp(-data.x[0]);
          break;
        case 1:
          values[0] = exp(-data.x[2]);
          break;
        default:
          values[0] = 0.0;
        }
      }

    };'''

    >>> cell_data = MeshFunction('uint', V.mesh(), 2)
    >>> f = Expression(V, code)
    >>> f.cell_data = cell_data

    3. User-defined expressions by subclassing
    ----------------------------------------

    The user can subclass Expression and overload the 'eval' function. The subclass
    must then instantiated using a FunctionSpace or an ufl.FiniteElement:

    >>> class MyExpression0(Expression):
            def eval(self, value, x):
                dx = x[0] - 0.5
                dy = x[1] - 0.5
                value[0] = 500.0*exp(-(dx*dx + dy*dy)/0.02)
    >>> f0 = MyExpression0(V = V)

    The user can also subclass Expression overloading the eval_data function. By
    this the user get access to the more powerfull Data structure, with e.g., cell,
    facet and normal information, during assemble.

    >>> class MyExpression1(Expression):
            def eval_data(self, value, data):
                if data.cell().index() > 10:
                    value[0] = 1.0
                else:
                    value[0] = -1.0

    >>> f1 = MyExpression1(V = V)

    Note that subclassing may be significantly slower than using JIT-compiled
    expressions. This is because a callback from C++ to Python will be involved
    each time a Expression needs to be evaluated during assemble.

    4. User-defined JIT-compiled expressions by subclassing
    -----------------------------------------------------

    The user can also subclass Expression and define the same attributes as described
    above for JIT-compiled expressions: 'cpparg' and 'defaults'.

    >>> class MyExpression0(Expression):
            cpparg = 'A*exp(-(pow(x[0]-0.5,2) + pow(x[1]-0.5,2))/B)'
            defaults = {"A": 500.0, "B": 0.02}
    >>> f0 = MyExpression0(V = V)

    >>> class MyExpression1(Expression):
            cpparg = code # See above for an example code.
    >>> f1 = MyExpression1(V = V)
    >>> f1.cell_data = mf

    This is useful for example when the Expression needs to initialize or
    precompute data, that is, when it behaves like a "functor".

    """

    # Set the meta class
    __metaclass__ = ExpressionMetaClass

    def __new__(cls, cpparg=None, defaults=None, element=None, degree=None):
        """ Instantiate a new Expression

        Arguments:
        ----------
        @param cpparg:
          C++ argument.
        @param defaults:
          Optional C++ argument.
        @param element:
          Optional ufl.FiniteElement argument.
        @param degree:
          Optional quadrature degree element.
        """

        # If the __new__ function is called because we are instantiating a sub
        # class of Expression, then use the object's __new__ function instead
        if cls.__name__ != "Expression":
            return object.__new__(cls)

        # Check arguments
        _check_cpparg(cpparg)
        _check_defaults(defaults)

        # Compile module and get the cpp.Expression class
        cpp_base = compile_expressions([cpparg], [defaults])[0]

        # Store arguments for later use
        cpp_base.cpparg = cpparg
        cpp_base.defaults = defaults
        cpp_base.element = element
        cpp_base.degree = degree
        return object.__new__(create_expression_class("CompiledExpression", cpp_base))

    def ufl_element(self):
        " Return the ufl FiniteElement."
        return self._ufl_element

    def __str__(self):
        # FIXME: We might change this using rank and dimension instead
        return "<Expression on a %s>" % str(self._ufl_element)

    def __repr__(self):
        return ufl.Function.__repr__(self)

def Expressions(*args, **kwargs):
    """ Batch-processed user-defined JIT-compiled expressions
    -------------------------------------------------------

    By specifying several cppargs one may compile more than one expression
    at a time. These may either be instantiated using a single FunctionSpace
    common for all expressions, using the optional kwarg 'V', or with
    a separate FunctionSpace for each cpparg:

    >>> f0, f1 = Expressions('sin(x[0]) + cos(x[1])', 'exp(x[1])', degree=3)
    >>> f0, f1 = Expressions('sin(x[0]) + cos(x[1])', 'exp(x[1])', element=element)

    Here cppcode is a code snippet, which should be a string of C++
    code that implements a class that inherits from dolfin::Expression,
    see user case 3. in Expression docstring

    Batch-processing of JIT-compiled expressions may significantly speed up
    JIT-compilation at run-time.

"""

    # Get the element/degree from kwarg
    degree  = kwargs.pop("degree", None)
    element = kwargs.pop("element", None)
    if len(kwargs) > 1:
        raise TypeError, "Can only define one kwarg and that can only be 'degree' or 'element'."

    # Check the number of args
    nargs = len(args)

    # Iterate over the *args and collect input to compile_expressions
    cppargs = []; defaults = []; i = 0;
    while i < nargs:
        if not isinstance(args[i],(tuple, list, str)):
            raise TypeError, "Expected either a 'list', 'tuple' or 'str' for argument %d"%i
        cppargs.append(args[i])
        defaults.append(None)
        i += 1

    # Compile the cpp.Expressions
    cpp_bases = compile_expressions(cppargs, defaults)

    # Instantiate the return arguments
    return_expressions = []

    for i, cpp_base in enumerate(cpp_bases):
        return_expressions.append(create_expression_class("CompiledExpression", cpp_base)
                                 (cppargs[i], element=element, degree=degree))

    # Return the instantiated Expressions
    return tuple(return_expressions)

# Assign doc string
expression__call__.__doc__

# Assign __call__ method
Expression.__call__ = types.MethodType(expression__call__, None, Expression)

#--- Utility functions ---

def _check_cpparg(cpparg):
    "Check that cpparg makes sense"

    if cpparg is None: return

    # Check that we get a string expression or nested expression
    if not isinstance(cpparg, (str, tuple, list)):
        raise TypeError, "Please provide a 'str', 'tuple' or 'list' for the 'cpparg' argument."

def _check_defaults(defaults):
    "Check that defaults makes sense"

    if defaults is None: return

    # Check that we get a dictionary
    if not isinstance(defaults, dict):
        raise TypeError, "Please provide a 'dict' for the 'defaults' argument."

    # Check types of the values in the dict
    for key, val in defaults.iteritems():
        if not isinstance(key,str):
            raise TypeError, "All keys in 'defaults' must be a 'str'."
        if not isinstance(val, (int, float)):
            raise TypeError, "All values in 'defaults' must be scalars."

def _is_complex_expression(cpparg):
    "Check if cpparg is a complex expression"
    return isinstance(cpparg, str) and "class" in cpparg and "Expression" in cpparg

def _auto_select_element_from_cpparg(cpparg, degree=None):
    "Automatically select an appropriate element from cpparg."

    # Use numpy to get the shape
    shape = numpy.shape(cpparg)

    return _auto_select_element_from_shape(shape, degree)

def _auto_select_element_from_dim(dim, degree=None):
    "Automatically select an appropriate element from dim."

    cpp.info("Got expression dimension = " + str(dim))

    # Check dim to get shape
    if isinstance(dim, int):
        if dim == 0:
            shape = ()
        else:
            shape = (dim,)
    elif isinstance(dim, (tuple, list)):
        shape = dim
    else:
        cpp.error("Expecting shape to be an integer or a tuple/list, not %s." % str(type(dim)))

    return _auto_select_element_from_shape(shape, degree)

def _auto_select_element_from_shape(shape, degree=None):
    "Automatically select an appropriate element from cpparg."

    # Default element, change to quadrature when working
    Family = "Lagrange"

    # Check if scalar, vector or tensor valued
    if len(shape) == 0:
        element = ufl.FiniteElement(Family, None, degree)
    elif len(shape) == 1:
        element = ufl.VectorElement(Family, None, degree, dim=shape[0])
    else:
        element = ufl.TensorElement(Family, None, degree, shape=shape)

    cpp.info("Automatic selection of expression element: " + str(element))

    return element
