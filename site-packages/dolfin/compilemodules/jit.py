"""This module defines a jit function that wraps the jit function for
the chosen form compiler."""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-12-04 -- 2009-12-11"
__copyright__ = "Copyright (C) 2008-2009 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008-2009.

__all__ = ["jit"]

# Import SWIG-generated extension module (DOLFIN C++)
import dolfin.cpp as cpp
from dolfin.cpp import MPI, info

# Set UFL log level
import ufl
ufl.set_level(ufl.INFO)

# Import check for correct swig version from instant
from instant import check_swig_version, get_swig_version

def mpi_jit_decorator(local_jit, *args, **kwargs):
    """A decorator for jit compilation

    Use this function as a decorator to any jit compiler function.  In
    a paralell run, this function will first call the jit compilation
    function on the first process. When this is done, and the module
    is in the cache, it will call the jit compiler on the remaining
    processes, which will then use the cached module.

    Usage:

        @mpi_jit_decorator
        def jit_something(something):
            ....

    """
    def mpi_jit(*args, **kwargs):

        # Just call JIT compiler when running in serial
        if MPI.num_processes() == 1:
            return local_jit(*args, **kwargs)

        # Compile first on process 0
        if MPI.process_number() == 0:
            output = local_jit(*args, **kwargs)

        # Wait for the first process to finish
        MPI.barrier()

        # Then compile on all other processes (which may then just read the cache)
        if not MPI.process_number() == 0:
            output = local_jit(*args,**kwargs)

        return output

    # Return the decorated jit function
    return mpi_jit

@mpi_jit_decorator
def jit(form, options=None):
    """Just-in-time compile any provided form.

    It uses the jit function from the form compiler registered by
    parameters["form_compiler"].
    """

    # Set form compiler log level and prefix
    options = (options or {}).copy()
    if not "log_level" in options:
        options["log_level"] = ufl.INFO + 5
    if not "log_prefix" in options and MPI.num_processes() > 1:
        options["log_prefix"] = "Process %d: " % MPI.process_number()

    # Check that the form compiler will use the same swig version
    # that PyDOLFIN was compiled with
    if not check_swig_version(cpp.__swigversion__,same=True):
        raise OSError, """PyDOLFIN was not compiled with the present version of swig.
Install swig version %s or recompiled PyDOLFIN with present swig
"""%cpp.__swigversion__

    # Import form compiler
    form_compiler_name = cpp.parameters["form_compiler"]
    try:
        form_compiler = __import__(form_compiler_name)
    except ImportError, message:
        print message
        raise RuntimeError, "Could not import %s form compiler." % form_compiler_name

    # Get jit function
    try:
        jit_compile = form_compiler.jit
    except AttributeError:
        raise RuntimeError, "Form compiler must implement the jit function."

    # FIXME: Figure out how to handle options for different form compilers

    # Set form compiler options
    if cpp.parameters["form_compiler"] == "ffc":
        if options is None:
            options = {}
        if not "cpp optimize" in options:
            options["cpp optimize"] = cpp.parameters["optimize_form"] or cpp.parameters["optimize"]
        if not "ffc_representation" in options:
            options["representation"] = cpp.parameters["ffc_representation"]

    return jit_compile(form, options)
