"This module provides functionality for compilation of strings as dolfin SubDomains."

__author__ = "Martin Sandve Alnes (martinal@simula.no)"
__date__ = "2008-07-01 -- 2008-08-07"
__copyright__ = "Copyright (C) 2008-2008 Martin Sandve Alnes"
__license__  = "GNU LGPL Version 2.1"

import re
import md5
import numpy
import instant

__all__ = ["compile_subdomains",]

# FIXME: Extend this list, needed to autodetect variable names that are not builtins
_builtins = [
             # local symbols:
             "pi", "DOLFIN_EPS",
             # cmath funcions:
             "cos", "sin", "tan", "acos", "asin", "atan", "atan2",
             "cosh", "sinh", "tanh",
             "exp", "frexp", "ldexp", "log", "log10", "modf",
             "pow", "sqrt", "ceil", "fabs", "floor", "fmod",
            ]
_eval_args = ["x", "v"]
_inside_args = ["x", "on_boundary"]
_map_args = ["x", "y"]


# Add utility code here
_header = """
// cmath functions
using std::cos;
using std::sin;
using std::tan;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;

const double pi = acos(-1.0);
"""


_subdomain_template = """
class %(classname)s: public dolfin::SubDomain
{
public:
%(members)s

  %(classname)s()
  {
%(constructor)s
  }

  /// Return true for points inside the sub domain
  bool inside(const dolfin::real* x, bool on_boundary) const
  {
    %(inside)s
  }

};
"""

# TODO: Support implementation of map as well
"""
  /// Map coordinate x in domain H to coordinate y in domain G (used for periodic boundary conditions)
  void map(const dolfin::real* x, dolfin::real* y) const
  {
    %(map)s
  }
"""

def expression_to_subdomain(e, classname):
    "Generates code for a dolfin::SubDomain subclass for a single expression."
    # Assure we have a simple string expression
    assert isinstance(e, str)
    
    # Autodetect variables from function strings
    variables = set()
    # Find groups of connected alphanumeric letters
    symbols = re.findall(r"([a-zA-Z_][\w]*)", e)
    assert isinstance(symbols, list)
    variables.update(symbols)
    # Remove builtin symbols
    variables.difference_update(_builtins)
    variables.difference_update(_map_args)
    variables.difference_update(_inside_args)
    
    # Generate code for member variables
    memberscode = "\n".join("  double %s;" % name for name in variables)
    
    # Generate constructor code for initialization of member variables
    constructorcode = "\n".join("    %s = 0.0;" % name for name in variables)
    
    # Generate code for inside()
    insidecode = "  return %s;" % e
    
    # Generate code for map()
    #mapcode = "..."
    
    # Connect the code fragments using the function template code
    fragments = {}
    fragments["classname"] = classname
    fragments["members"]   = memberscode
    fragments["constructor"] = constructorcode
    fragments["inside"]    = insidecode
    #fragments["map"]       = mapcode
    code = _subdomain_template % fragments
    return code


def generate_subdomains(expressions):
    "Generates code for dolfin::SubDomain subclasses for a list of expressions."
    assert isinstance(expressions, list)
    code = ""
    classnames = []
    for e in expressions:
        classname = "subdomain_%s" % md5.md5(repr(e)).hexdigest()
        code += expression_to_subdomain(e, classname)
        classnames.append(classname)
    return code, classnames

# NB! This code is highly dependent on the dolfin swig setup!
_additional_declarations = r"""
%include exception.i
%include cpointer.i
%pointer_class(int, intp);
%pointer_class(double, doublep);
//%include std_vector.i
//%template(STLVectorFunctionPtr) std::vector<dolfin::Function *>;
%import dolfin.i
"""

_additional_definitions  = """
#include <dolfin.h>
//using namespace dolfin;
#include <numpy/arrayobject.h>
"""

def compile_subdomain_code(code, classnames=None, module_name=None):
    # Create unique module name for this application run
    global _header, _additional_definitions, _additional_declarations
    if module_name is None:
        module_name = "dolfin_compile_subdomain_%s" % md5.md5(repr(code) + repr(classnames)).hexdigest()

    # Autodetect classnames:
    _classnames = re.findall(r"class[ ]+([\w]+).*", code)
    # Just a little assertion for safety:
    if classnames is None:
        classnames = _classnames
    else:
        assert all(a == b for (a,b) in zip(classnames, _classnames))
    
    # Get system configuration   
    (includes, flags, libraries, libdirs) = instant.header_and_libs_from_pkgconfig("dolfin")
    dolfin_include_dir = includes[0] # FIXME: is this safe?
    numpy_dir = numpy.get_include()
    includes.append(numpy_dir)
    
    sysheaders = ["cmath", "iostream", "stdexcept",
                  "dolfin.h", "dolfin/mesh/SubDomain.h"]
    
    # FIXME: use dolfin flags?
    cppargs = flags
    
    # Let swig see the installed dolfin swig files
    swigopts = "-c++ -I%s -I%s/dolfin/swig" % (dolfin_include_dir, dolfin_include_dir)
    
    # Compile extension module with instant
    compiled_module = instant.create_extension(\
             code           = _header + code,
             module         = module_name,
             swigopts       = swigopts,
             system_headers = sysheaders,
             include_dirs   = includes,
             #cppargs        = cppargs,
             libraries      = libraries,
             library_dirs   = libdirs,
             additional_definitions  = _additional_definitions,
             additional_declarations = _additional_declarations
             )
    compiled_module = __import__(module_name)
    
    # Construct instances of the compiled subdomain classes
    subdomains = [eval("compiled_module.%s()" % name) for name in classnames]
    return subdomains


def compile_subdomains(expressions):
    """Compiles C++ string expressions into dolfin::SubDomain instances.
    
    The variable 'expressions' can either be a str or a list.
    
    If 'expressions' is a str, it is interpreted as a C++ string
    with complete implementations of subclasses of dolfin::SubDomain.
    The compiled subdomains returned will be in the same order 
    as they are defined in this code.

    If it is a list, each item of the list is interpreted as
    a logical 'inside' expression, and the compiled subdomains 
    returned will be in the same order as they occur in this list.
    
    If an expression string contains a name, it is assumed to
    be a scalar variable name, and is added as a public member
    of the generated subdomain. The exceptions are set in the
    variable dolfin.compile_subdomains._builtins."""
    #, which contains:
    #    %s
    #""" % "\n".join("        " + b for b in _builtins)
    if isinstance(expressions, list):
        code, classnames = generate_subdomains(expressions)
        subdomains = compile_subdomain_code(code, classnames)
    else:
        subdomains = compile_subdomain_code(expressions)
    return subdomains


if __name__ == "__main__":
    code, cn = generate_subdomains(["x[0] >= 1.0-DOLFIN_EPS", "on_boundary && x[1] < xlen+DOLFIN_EPS"])
    print code
    print cn


