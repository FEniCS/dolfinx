"""This module provides a simple way to compute various norms of
Functions, including the standard L2 norm and other norms"""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2008-03-19 -- 2008-09-22"
__copyright__ = "Copyright (C) 2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

__all__ = ['norm']

from assemble import assemble
from ffc import dot, grad, div, curl, dx
from math import sqrt
from constants import DOLFIN_EPS 

def norm(v, mesh, type="L2"):

    """Return norm of given function. Example usage includes:

        norm(v, mesh)
        norm(u0 - u1, mesh)
        norm(v, mesh, 'Hdiv')
        
    If the type is not specified, the standard L^2 norm is
    computed. Possible norm types include:

      L^2:     norm(v, mesh, 'L2')
      H^1:     norm(v, mesh, 'H1')      includes L^2 term
      H^1_0:   norm(v, mesh, 'H10')     does not include L^2 term
      H(div):  norm(v, mesh, 'Hdiv')    includes L^2 term
      H(div):  norm(v, mesh, 'Hdiv0')   does not include L^2 term
      H(curl): norm(v, mesh, 'Hcurl0')  includes L^2 term
      H(curl): norm(v, mesh, 'Hcurl0')  does not include L^2 term
    """

    # Choose functional
    if type.lower() == "l2":
        M = dot(v, v)*dx
    elif type.lower() == "h1":
        M = dot(v, v)*dx + dot(grad(v), grad(v))*dx
    elif type.lower() == "h10":
        M = dot(grad(v), grad(v))*dx
    elif type.lower() == "hdiv":
        M = dot(v, v)*dx + div(v)*div(v)*dx
    elif type.lower() == "hdiv0":
        M = div(v)*div(v)*dx
    elif type.lower() == "hcurl":
        M = dot(v, v)*dx + dot(curl(v), curl(v))*dx
    elif type.lower() == "hcurl0":
        M = dot(curl(v), curl(v))*dx
    else:
        error("Unknown norm type: " + str(type))

    # Assemble value
    r = assemble(M, mesh)

    # Check value
    if r < 0.0:
        error("Unable to compute norm, square of norm is negative (round-off errors?).")
    elif r < DOLFIN_EPS:
        return 0.0
    else:
        return sqrt(r)
