__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2009-12-11"
__copyright__ = "Copyright (C) 2008 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008.
# Modified by Martin Alnes, 2008.
# Modified by Kent-Andre Mardal 2009.

__all__ = ["FunctionSpace", "MixedFunctionSpace",
           "VectorFunctionSpace", "TensorFunctionSpace",
           "FunctionSpaceBase","FunctionSpaceFromCpp",
           "create_ufc_function_spaces"]

import copy

# Import UFL and SWIG-generated extension module (DOLFIN C++)
import ufl

import dolfin.cpp as cpp
from dolfin.compilemodules.jit import jit

# Mapping from dimension to domain
dim2domain = {1: "interval", 2: "triangle", 3: "tetrahedron"}

class FunctionSpaceBase(cpp.FunctionSpace):
    "Base class for all function spaces."

    def __init__(self, mesh, element):
        "Create function space on given mesh for given finite element."

        # Check arguments
        if not isinstance(mesh, cpp.Mesh):
            cpp.error("Illegal mesh for creation of function space, not a mesh: " + str(mesh))
        if not isinstance(element, (ufl.FiniteElementBase)):
            cpp.error("Illegal finite element for creation of function space, not a finite element: " + str(element))

        # Store element
        # Note: self._element cannot be a private attribute as we want to be able to
        #       set the element from a derived class.
        self._ufl_element = element

        # JIT-compile element to get ufc_element and ufc_dofmap
        ufc_element, ufc_dofmap = jit(self._ufl_element)

        # Instantiate DOLFIN FiniteElement and DofMap
        self._dolfin_element = cpp.FiniteElement(ufc_element)
        dolfin_dofmap  = cpp.DofMap(ufc_dofmap, mesh)

        # Initialize the cpp_FunctionSpace
        cpp.FunctionSpace.__init__(self, mesh,
                                   self._dolfin_element,
                                   dolfin_dofmap)

    # FIXME: Sort out consistent interface for access to DOLFIN, UFL and UFC objects...

    def cell(self):
        "Return the ufl cell."
        return self._ufl_element.cell()

    def ufl_element(self):
        "Return the UFL element."
        return self._ufl_element

    def dolfin_element(self):
        "Return the DOLFIN element."
        return self._dolfin_element

    def __add__(self, other):
        "Create enriched function space."
        # FIXME: Remove this comment after the release of DOLFIN 0.9.8
        cpp.warning("The meaning of operator '+' has changed (no longer creating a mixed function space).")
        return EnrichedFunctionSpace((self, other))

    def __mul__(self, other):
        "Create mixed function space."
        return MixedFunctionSpace((self, other))

    def __str__(self):
        "Pretty-print."
        return "<Function space of dimension %d (%s)>" % (self.dofmap().global_dimension(), str(self._ufl_element))

    def num_sub_spaces(self):
        " Return the number of sub spaces"
        return self._dolfin_element.num_sub_elements()

    def sub(self, i):
        "Return the i:th cpp.SubSpace"
        # Fixme: Should we have a more extensive check other than whats included in
        # the cpp code?
        #if i not in self._cpp_sub_spaces.keys():
            # Store the created subspace to prevent swig garbage collection
            # Should not be needed as SubSpace is shared_ptr stored
        #    self._cpp_sub_spaces[i] = FunctionSpaceFromCpp(cpp.SubSpace(self,i))
        if not isinstance(i, int):
            raise TypeError, "expected an int for 'i'"
        if self.num_sub_spaces() == 1:
            raise ValueError, "no SubSpaces to extract"
        if i >= self.num_sub_spaces():
            raise ValueError, "Can only extract SubSpaces with i = 0..%d"%(self.num_sub_spaces()-1)
        assert(hasattr(self._ufl_element,"sub_elements"))
        element = self._ufl_element.sub_elements()[i]
        return FunctionSpaceFromCpp(cpp.SubSpace(self,i), element)

    def split(self):
        S = []
        for i in range(self.num_sub_spaces()):
            S.append(self.sub(i))
        return S

class FunctionSpaceFromCpp(FunctionSpaceBase):
    " FunctionSpace represents a finite element function space."
    def __init__(self, cppV, element=None):
        """ Initialize a FunctionSpace from an already excisting
            cpp.FunctionSpace
        """
        if not isinstance(cppV, (cpp.FunctionSpace)):
            cpp.error("Illegal argument for creation of function space, not an other cpp.FunctionSpace: " + str(cppV))

        if element is None:
            # Get the ufl.FiniteElement from the compiled element sigature
            self._ufl_element = eval(cppV.element().signature(), ufl.__dict__)
        else:
            if not isinstance(element, ufl.FiniteElementBase):
                raise TypeError, "expected a ufl.FiniteElementBase"
            self._ufl_element = element

        # Init the cpp.FunctionSpace with the provided cppV
        cpp.FunctionSpace.__init__(self, cppV)

        # Assign the dolfin element
        self._dolfin_element = cpp.FunctionSpace.element(self)

def create_ufc_function_spaces(mesh, ufc_form, cache=None):
    """ Instantiate cpp.FunctionSpaces from compiled ufc form

    >>> fs0, c = create_ufc_function_spaces(mesh, ufc_form0)
    >>> fs1, c = create_ufc_function_spaces(mesh, ufc_form1, c)

    @param mesh     : The mesh
    @param ufc_form : compiled ufc form
    @param cache    : A dict with allready instantiated cpp.FunctionSpaces
    """

    # Initialize return arguments
    functionspaces = []
    if cache is None:
        cache = {}

    # Iterate over all known ufc_finite_elements
    for i in range(ufc_form.rank() + ufc_form.num_coefficients()):
        # Create a ufc_finite_elements
        fe = ufc_form.create_finite_element(i)

        # Use the signature of the element as key in the cache dict
        fesig = fe.signature()

        # Try to access the cache
        V = cache.get(fesig)

        # If the cpp.FunctionSpace does not excists in the cache
        if V is None:
            # Instantiate a dofmap
            dm = ufc_form.create_dofmap(i)

            # Instantiate the UFCFunctionSpace
            V = UFCFunctionSpace(mesh, fe, dm)
            cache[fesig] = V

        functionspaces.append(V)

    return functionspaces, cache

class UFCFunctionSpace(cpp.FunctionSpace):
    "FunctionSpace represents a finite element function space."
    def __init__(self, mesh, ufc_finite_element, ufc_dofmap):
        " Initialize a FunctionSpace from ufc data "
        self._mesh = mesh
        self._finite_element     = cpp.FiniteElement(ufc_finite_element)
        self._dofmap            = cpp.DofMap(ufc_dofmap, mesh)
        self._ufc_finite_element = ufc_finite_element
        self._ufc_dofmap        = ufc_dofmap
        cpp.FunctionSpace.__init__(self, self._mesh, self._finite_element, self._dofmap)

class FunctionSpace(FunctionSpaceBase):
    "FunctionSpace represents a finite element function space."

    def __init__(self, mesh, family, degree, form_degree=None,
                 restriction=None):
        """Create finite element function space. The function space
        may be created by

            V = FunctionSpace(mesh, family, degree)

            mesh        : a Mesh
            family      : a string specifying the element family
            degree      : the degree of the element
            form_degree : used for FEEC notation
            restriction : restriction of the element (e.g. to cell facets)

        Which families and degrees that are supported is determined by the
        form compiler used to generate the element, but typical families
        include

            Lagrange
            Discontinuous Lagrange
            Bubble
            Crouzeix-Raviart
            Brezzi-Douglas-Marini
            Brezzi-Douglas-Fortin-Marini
            Raviart-Thomas
            Nedelec 1st kind H(curl)
            Nedelec 2nd kind H(curl)
            Quadrature
            Boundary Quadrature
        """

        # Check arguments
        if not isinstance(mesh, cpp.Mesh):
            cpp.error("Illegal mesh for creation of function space, not a mesh: " + str(mesh))
        if not isinstance(family, str):
            cpp.error("Illegal family for creation of function space, not a string: " + str(family))
        if not isinstance(degree, int):
            cpp.error("Illegal degree for creation of function space, not an integer: " + str(degree))
        dim = mesh.topology().dim()
        if not dim in dim2domain:
            cpp.error("Invalid mesh dimension: " + str(dim))

        # Create element
        domain = dim2domain[mesh.topology().dim()]
        element = ufl.FiniteElement(family, domain, degree,
                                    form_degree=form_degree)
        if restriction is not None:
            element = element[restriction]

        # Initialize base class
        FunctionSpaceBase.__init__(self, mesh, element)

        self.___degree = degree
        self.___family = family
        self.___mesh = mesh
        self.___form_degree = form_degree

    def restriction(self, meshfunction):
        space = FunctionSpace(self.___mesh, self.___family, self.___degree,
                              form_degree=self.___form_degree)
        space.attach(meshfunction)
        return space

class EnrichedFunctionSpace(FunctionSpaceBase):
    "EnrichedFunctionSpace represents an enriched finite element function space."

    def __init__(self, spaces):
        """Create enriched finite element function space. The function space
        may be created by

            V = EnrichedFunctionSpace(spaces)

        where spaces is a list (or tuple) of function spaces.
        """

        # Check arguments
        if not len(spaces) > 0:
            cpp.error("Enriched function space needs at least one subspace.")
        if not all(isinstance(V, FunctionSpaceBase) for V in spaces):
            cpp.error("Invalid subspaces: " + str(spaces))
        #if not all(V.mesh() == spaces[0].mesh() for V in spaces):
        #    cpp.error("Nonmatching meshes for mixed function space: " + str([V.mesh() for V in spaces]))

        # Create element
        element = ufl.EnrichedElement(*[V.ufl_element() for V in spaces])

        # Initialize base class
        FunctionSpaceBase.__init__(self, spaces[0].mesh(), element)

class MixedFunctionSpace(FunctionSpaceBase):
    "MixedFunctionSpace represents a mixed finite element function space."

    def __init__(self, spaces):
        """Create mixed finite element function space. The function space
        may be created by

            V = MixedFunctionSpace(spaces)

        where spaces is a list (or tuple) of function spaces.
        """

        # Check arguments
        if not len(spaces) > 0:
            cpp.error("Mixed function space needs at least one subspace.")
        if not all(isinstance(V, FunctionSpaceBase) for V in spaces):
            cpp.error("Invalid subspaces: " + str(spaces))
        #if not all(V.mesh() == spaces[0].mesh() for V in spaces):
        #    cpp.error("Nonmatching meshes for mixed function space: " + str([V.mesh() for V in spaces]))

        # Create element
        element = ufl.MixedElement(*[V.ufl_element() for V in spaces])

        # Initialize base class
        FunctionSpaceBase.__init__(self, spaces[0].mesh(), element)

class VectorFunctionSpace(MixedFunctionSpace):
    "VectorFunctionSpace represents a vector-valued finite element function space."

    def __init__(self, mesh, family, degree, dim=None, restriction=None):
        """Create vector-valued finite element function space. The function space
        may be created by

            mesh    : a Mesh
            family  : a string specifying the element family
            degree  : the degree of the element
            dim     : an optional argument specifying the number of components

        If the dim argument is not provided, the dimension will be deduced from
        the dimension of the mesh.
        """

        # Create subspaces
        dim = dim or mesh.geometry().dim()
        spaces = dim*[FunctionSpace(mesh, family, degree,
                                    restriction=restriction)]

        # Initialize base class
        MixedFunctionSpace.__init__(self, spaces)

# FIXME: Add this class:
# UFL: class TensorFunctionSpace(MixedFunctionSpace): ...

class TensorFunctionSpace(FunctionSpaceBase):
    "TensorFunctionSpace represents a tensor-valued finite element function space."

    def __init__(self, mesh, family, degree, shape=None, symmetry=None, restriction=None):
        """Create tensor-valued finite element function space. The function space
        may be created by

            mesh    : a Mesh
            family  : a string specifying the element family
            degree  : the degree of the element
            shape   : an optional argument specifying the shape of the tensor
            symmetry: an optional argument specifying whether the tensor is symmetric

        If the dim argument is not provided, the dimension will be deduced from
        the dimension of the mesh.
        """

        # Create subspaces
        if shape == None:
            dim = mesh.topology().dim()
            shape = (dim,dim)
        cell = dim2domain[mesh.topology().dim()]
        element = ufl.TensorElement(family, cell, degree, shape, symmetry)
        if restriction is not None:
            element = element[restriction]


        # Initialize base class
        FunctionSpaceBase.__init__(self, mesh, element)
