"""This module handles the PDE classes in Python. These need special
handling and are not wrapped by SWIG since they need to call the JIT
compiler."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2007-08-15 -- 2008-10-01"
__copyright__ = "Copyright (C) 2007-2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

__all__ = ["LinearPDE"]

import dolfin
from assemble import *
from function import *
from bc import *

# LinearPDE class
class LinearPDE:
    """A LinearPDE represents a (system of) linear partial differential
    equation(s) in variational form: Find u in V such that
    
        a(v, u) = L(v) for all v in V',

    where a is a bilinear form and L is a linear form."""

    def __init__(self, a, L, mesh, bcs=[], matrix_type=dolfin.nonsymmetric, solver_type=None):
        "Create LinearPDE"

        self.a = a
        self.L = L
        self.mesh = mesh
        self.bcs = bcs
        self.dof_maps = dolfin.DofMapSet()
        self.matrix_type = matrix_type
        self.solver_type = solver_type

        # Make sure we have a list
        if not isinstance(self.bcs, list):
            self.bcs = [self.bcs]

    def solve(self):
        "Solve PDE and return solution"

        # Check for periodic boundary conditions
        periodic_bc = False
        for bc in self.bcs:
            if isinstance(bc, PeriodicBC):
                periodic_bc = True
                break

        dolfin.begin("Solving linear PDE.");

        # FIXME: Maybe there is a better solution?
        # Compile form, needed to create discrete function
        (compiled_form, module, form_data) = jit(self.a)

        # Assemble linear system and apply boundary conditions
        if periodic_bc:
            # Application of periodic boundary conditions will break any symmetry of the matrix
            self.matrix_type = dolfin.nonsymmetric
            (A, self.dof_maps) = assemble(self.a, self.mesh, return_dofmaps=True)
            (b, dof_maps_L)    = assemble(self.L, self.mesh, return_dofmaps=True)

            # Apply boundary conditions
            for bc in self.bcs:
                if isinstance(bc, DirichletBC):
                    dolfin.cpp_DirichletBC.apply(bc, A, b, self.dof_maps.sub(1), compiled_form)
                elif isinstance(bc, PeriodicBC):
                    dolfin.cpp_PeriodicBC.apply(bc, A, b, self.dof_maps.sub(1), compiled_form)
                else:
                    raise RuntimeError("Unable to apply boundary conditions, unknown type: " + str(bc))
        else:
            (A, self.dof_maps, b, dof_maps_L) = assemble_system(self.a, self.L, self.bcs, self.mesh, return_dofmaps=True)

        #message("Matrix:")
        #A.disp()

        #message("Vector:")
        #b.disp()

        # Get trial element
        element = form_data.elements[1]
  
        # Create Function
        u = Function(element, self.mesh, self.dof_maps.sub(1), compiled_form)

        # Choose linear solver
        if self.solver_type is None:
            solver_type_str = dolfin.dolfin_get("PDE linear solver")
            if solver_type_str == "direct":
                solver_type = dolfin.lu
            elif solver_type_str == "iterative":
                solver_type = dolfin.gmres
            else:
                error("Unknown solver type \"%s\"." % solver_type_str)
        else:
            solver_type = self.solver_type

        # Solver linear system
        dolfin.solve(A, u.vector(), b, solver_type)
        
        dolfin.end()

        return u
