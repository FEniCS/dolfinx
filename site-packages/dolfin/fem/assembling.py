"""This module provides functionality for form assembly in Python,
corresponding to the C++ assembly and PDE classes.

The C++ :py:class:`assemble <dolfin.cpp.assemble>` function
(renamed to cpp_assemble) is wrapped with an additional
preprocessing step where code is generated using the
FFC JIT compiler.

The C++ PDE classes are reimplemented in Python since the C++ classes
rely on the dolfin::Form class which is not used on the Python side."""

# Copyright (C) 2007-2008 Anders Logg
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# Modified by Martin Sandve Alnaes, 2008.
# Modified by Johan Hake, 2008-2009.
# Modified by Garth N. Wells, 2008-2013.
# Modified by Joachim B. Haga, 2012.

__all__ = ["assemble", "assemble_system", "SystemAssembler"]

import types

# UFL modules
from ufl import interval, triangle, tetrahedron

# Import SWIG-generated extension module (DOLFIN C++)
import dolfin.cpp as cpp

# Local imports
from dolfin.fem.form import *

def _create_dolfin_form(form,
                        form_compiler_parameters=None,
                        # TODO: Remove these after 1.4 release:
                        mesh=None,
                        coefficients=None,
                        function_spaces=None,
                        # TODO: Remove these after 1.5 release:
                        cell_domains=None,
                        exterior_facet_domains=None,
                        interior_facet_domains=None):

    # First check if we got a cpp.Form
    if isinstance(form, cpp.Form):
        assert hasattr(form, "_compiled_form")

        # Then we just try to use that one
        dolfin_form = form

        # Set mesh if specified (important for functionals without a function spaces)
        if mesh is not None:
            cpp.warning("Passing mesh modifies the input dolfin Form!")
            dolfin_form.set_mesh(mesh)
        if function_spaces is not None:
            cpp.warning("Ignoring function_spaces with a dolfin Form!")
        if coefficients is not None:
            cpp.warning("Ignoring coefficients with a dolfin Form!")
        if form_compiler_parameters is not None:
            cpp.warning("Ignoring form_compiler_parameters with a dolfin Form!")

    else:
        # Wrap form
        dolfin_form = Form(form,
                           form_compiler_parameters=form_compiler_parameters,
                           # TODO: Remove these after 1.4 release:
                           function_spaces=function_spaces,
                           coefficients=coefficients,
                           mesh=mesh)

    # Attach domains to form
    if cell_domains is not None:
        if form is dolfin_form:
            cpp.warning("Passing cell_domains modifies the input dolfin Form!")
        if not isinstance(cell_domains, cpp.MeshFunctionSizet):
            raise TypeError("expected a 'MeshFunction' of 'Sizet' or 'None', for argument 'cell_domains'")
        dolfin_form.set_cell_domains(cell_domains);
    if interior_facet_domains is not None:
        if form is dolfin_form:
            cpp.warning("Passing interior_facet_domains modifies the input dolfin Form!")
        if not isinstance(interior_facet_domains, cpp.MeshFunctionSizet):
            raise TypeError("expected a 'MeshFunction' of 'Sizet' or 'None', for argument 'interior_facet_domains'")
        dolfin_form.set_interior_facet_domains(interior_facet_domains);
    if exterior_facet_domains is not None:
        if form is dolfin_form:
            cpp.warning("Passing exterior_facet_domains modifies the input dolfin Form!")
        if not isinstance(exterior_facet_domains, cpp.MeshFunctionSizet):
            raise TypeError("expected a 'MeshFunction' of 'Sizet' or 'None', for argument 'exterior_facet_domains'")
        dolfin_form.set_exterior_facet_domains(exterior_facet_domains);

    return dolfin_form

# JIT assembler
def assemble(form,
             tensor=None,
             bcs=None,
             form_compiler_parameters=None,
             add_values=False,
             finalize_tensor=True,
             keep_diagonal=False,
             backend=None,
             # TODO: Remove after 1.5 release:
             cell_domains=None,
             exterior_facet_domains=None,
             interior_facet_domains=None,
             # TODO: Remove after 1.4 release:
             mesh=None,
             coefficients=None,
             function_spaces=None,
             ):
    """
    Assemble the given form and return the corresponding tensor.

    *Arguments*
        Depending on the input form, which may be a functional, linear
        form, bilinear form or higher rank form, a scalar value, a vector,
        a matrix or a higher rank tensor is returned.

    In the simplest case, no additional arguments are needed. However,
    additional arguments may and must in some cases be provided as
    outlined below.

    The ``form`` can be either an FFC form or a precompiled UFC
    form. If a precompiled or 'pure' UFC form is given, then
    ``coefficients`` and ``function_spaces`` have to be provided
    too. The coefficient functions should be provided as a 'dict'
    using the FFC functions as keys. The function spaces should be
    provided either as a list where the number of function spaces must
    correspond to the number of basis functions in the form, or as a
    single argument, implying that the same FunctionSpace is used for
    all test/trial spaces.

    If the form defines integrals over different subdomains,
    :py:class:`MeshFunctions <dolfin.cpp.MeshFunction>` over the
    corresponding topological entities defining the subdomains can be
    provided.

    The implementation of the returned tensor is determined by the
    default linear algebra backend. This can be overridden by
    specifying a different backend.

    Each call to assemble() will create a new tensor. If the
    ``tensor`` argument is provided, this will be used instead.
    Sparsity pattern of ``tensor`` is reset iff ``tensor.empty()`` holds.

    If the ``keep_diagonal`` is set to True, assembler ensures that
    potential zeros on a matrix diagonal are kept in sparsity pattern
    so every diagonal entry can be changed in a future (for example
    by ident() or ident_zeros()).

    Specific form compiler parameters can be provided by the
    ``form_compiler_parameters`` argument. Form compiler parameters
    can also be controlled using the global parameters stored in
    parameters["form_compiler"].

    *Examples of usage*
        The standard stiffness matrix ``A`` and a load vector ``b``
        can be assembled as follows:

        .. code-block:: python

            A = assemble(inner(grad(u),grad(v))*dx())
            b = assemble(f*v*dx())

        It is possible to explicitly prescribe the domains over which
        integrals wll be evaluated using the arguments
        ``cell_domains``, ``exterior_facet_domains`` and
        ``interior_facet_domains``. For instance, using a mesh
        function marking parts of the boundary:

        .. code-block:: python

            # MeshFunction marking boundary parts
            boundary_parts = MeshFunction("size_t", mesh, mesh.topology().dim()-1)

            # Sample variational forms
            a = inner(grad(u), grad(v))*dx() + p*u*v*ds(0)
            L = f*v*dx() - g*v*ds(1) + p*q*v*ds(0)

            A = assemble(a, exterior_facet_domains=boundary_parts)
            b = assemble(L, exterior_facet_domains=boundary_parts)

        To ensure that the assembled matrix has the right type, one may use
        the ``tensor`` argument:

        .. code-block:: python

            A = PETScMatrix()
            assemble(a, tensor=A)

        The form ``a`` is now assembled into the PETScMatrix ``A``.

    """
    if (mesh is not None
        or function_spaces is not None
        or coefficients is not None):
        cpp.deprecation("Parameters mesh, function_spaces and coefficients of assemble",
                        "1.4.0", "1.5.0",
                        "Parameter mesh, function_spaces and coefficients of assemble"
                        " will be removed. Include this in the ufl form instead.")
    if (cell_domains is not None
        or exterior_facet_domains is not None
        or interior_facet_domains is not None):
        cpp.deprecation("Parameters *_domains of assemble",
                        "1.4.0", "1.6.0",
                        "Parameter *_domains of assemble"
                        " will be removed. Include this in the ufl form instead.")

    # Create dolfin Form object referencing all data needed by assembler
    dolfin_form = _create_dolfin_form(form, form_compiler_parameters,
                                      mesh, coefficients, function_spaces,
                                      cell_domains, exterior_facet_domains, interior_facet_domains)

    # Create tensor
    tensor = _create_tensor(form, dolfin_form.rank(), backend, tensor)

    # Call C++ assemble function
    assembler = cpp.Assembler()
    assembler.add_values = add_values
    assembler.finalize_tensor = finalize_tensor
    assembler.keep_diagonal = keep_diagonal
    assembler.assemble(tensor, dolfin_form)

    # Convert to float for scalars
    if dolfin_form.rank() == 0:
        tensor = tensor.getval()

    # Apply (possibly list of) boundary conditions
    bcs = _wrap_in_list(bcs, 'bcs', cpp.DirichletBC)
    if bcs:
        cpp.deprecation("Passing \"bcs\" to assemble", "1.3.0", "1.4.0",
                        "Apply DirichletBC manually after an assemble.")
    for bc in bcs:
        bc.apply(tensor)

    # Return value
    return tensor

# JIT system assembler
def assemble_system(A_form,
                    b_form,
                    bcs=None,
                    x0=None,
                    form_compiler_parameters=None,
                    add_values=False,
                    finalize_tensor=True,
                    keep_diagonal=False,
                    A_tensor=None,
                    b_tensor=None,
                    backend=None,
                    # TODO: Remove after 1.4 release:
                    mesh=None,
                    A_coefficients=None,
                    b_coefficients=None,
                    A_function_spaces=None,
                    b_function_spaces=None,
                    # TODO: Remove after 1.5 release:
                    cell_domains=None,
                    exterior_facet_domains=None,
                    interior_facet_domains=None):
    """
    Assemble form(s) and apply any given boundary conditions in a
    symmetric fashion and return tensor(s).

    The standard application of boundary conditions does not
    necessarily preserve the symmetry of the assembled matrix. In
    order to perserve symmetry in a system of equations with boundary
    conditions, one may use the alternative assemble_system instead of
    multiple calls to :py:func:`assemble
    <dolfin.fem.assembling.assemble>`.

    *Examples of usage*

       For instance, the statements

       .. code-block:: python

           A = assemble(a)
           b = assemble(L)
           bc.apply(A, b)

       can alternatively be carried out by

       .. code-block:: python

           A, b = assemble_system(a, L, bc)

       The statement above is valid even if ``bc`` is a list of
       :py:class:`DirichletBC <dolfin.fem.bcs.DirichletBC>`
       instances. For more info and options, see :py:func:`assemble
       <dolfin.fem.assembling.assemble>`.

    """
    if (mesh is not None
        or A_function_spaces is not None
        or b_function_spaces is not None
        or A_coefficients is not None
        or b_coefficients is not None):
        cpp.deprecation("Parameters mesh, *_function_spaces and *_coefficients of assemble_system",
                        "1.4.0", "1.5.0",
                        "Parameters mesh, *_function_spaces and *_coefficients of assemble_system"
                        " will be removed. Include this in the ufl form instead.")
    if (cell_domains is not None
        or exterior_facet_domains is not None
        or interior_facet_domains is not None):
        cpp.deprecation("Parameters *_domains of assemble_system",
                        "1.4.0", "1.6.0",
                        "Parameters *_domains of assemble_system"
                        " will be removed. Include this in the ufl form instead.")

    # Create dolfin Form objects referencing all data needed by assembler
    A_dolfin_form = _create_dolfin_form(A_form, form_compiler_parameters,
                                        mesh, A_coefficients, A_function_spaces,
                                        cell_domains, exterior_facet_domains, interior_facet_domains)
    b_dolfin_form = _create_dolfin_form(b_form, form_compiler_parameters,
                                        mesh, b_coefficients, b_function_spaces,
                                        cell_domains, exterior_facet_domains, interior_facet_domains)

    # Create tensors
    A_tensor = _create_tensor(A_form, A_dolfin_form.rank(), backend, A_tensor)
    b_tensor = _create_tensor(b_form, b_dolfin_form.rank(), backend, b_tensor)

    # Check bcs
    bcs = _wrap_in_list(bcs, 'bcs', cpp.DirichletBC)

    # Call C++ assemble function
    assembler = cpp.SystemAssembler(A_dolfin_form, b_dolfin_form, bcs)
    assembler.add_values = add_values
    assembler.finalize_tensor = finalize_tensor
    assembler.keep_diagonal = keep_diagonal
    if x0 is not None:
        assembler.assemble(A_tensor, b_tensor, x0)
    else:
        assembler.assemble(A_tensor, b_tensor)

    return A_tensor, b_tensor

def _wrap_in_list(obj, name, types=type):
    if obj is None:
        lst = []
    elif hasattr(obj, '__iter__'):
        lst = list(obj)
    else:
        lst = [obj]
    for obj in lst:
        if not isinstance(obj, types):
            raise TypeError("expected a (list of) %s as '%s' argument" % (str(types),name))
    return lst

def _create_tensor(form, rank, backend, tensor):
    "Create tensor for form"

    # Check if tensor is supplied by user
    if tensor is not None:
        return tensor

    # Check backend argument
    if (not backend is None) and (not isinstance(backend, cpp.GenericLinearAlgebraFactory)):
        raise TypeError("Provide a GenericLinearAlgebraFactory as 'backend'")

    # Create tensor
    if rank == 0:
        tensor = cpp.Scalar()
    elif rank == 1:
        if backend: tensor = backend.create_vector()
        else:       tensor = cpp.Vector()
    elif rank == 2:
        if backend: tensor = backend.create_matrix()
        else:       tensor = cpp.Matrix()
    else:
        raise RuntimeError("Unable to create tensors of rank %d." % rank)

    return tensor

class SystemAssembler(cpp.SystemAssembler):
    __doc__ = cpp.SystemAssembler.__doc__
    def __init__(self, A_form, b_form,
                 bcs=None,
                 form_compiler_parameters=None,
                 # TODO: Remove after 1.4 release:
                 mesh=None,
                 A_coefficients=None,
                 b_coefficients=None,
                 A_function_spaces=None,
                 b_function_spaces=None,
                 # TODO: Remove after 1.5 release:
                 cell_domains=None,
                 exterior_facet_domains=None,
                 interior_facet_domains=None):
        """
        Create a SystemAssembler

        * Arguments *
           a (ufl.Form, _Form_)
              Bilinear form
           L (ufl.Form, _Form_)
              Linear form
           bcs (_DirichletBC_)
              A list or a single DirichletBC (optional)
        """
        if (mesh is not None
            or A_function_spaces is not None
            or b_function_spaces is not None
            or A_coefficients is not None
            or b_coefficients is not None):
            cpp.deprecation("Parameters mesh, *_function_spaces and *_coefficients of SystemAssembler",
                            "1.4.0", "1.5.0",
                            "Parameters mesh, *_function_spaces and *_coefficients of SystemAssembler"
                            " will be removed. Include this in the ufl form instead.")
        if (cell_domains is not None
            or exterior_facet_domains is not None
            or interior_facet_domains is not None):
            cpp.deprecation("Parameters *_domains of SystemAssembler",
                            "1.4.0", "1.6.0",
                            "Parameters *_domains of SystemAssembler"
                            " will be removed. Include this in the ufl form instead.")
        # Create dolfin Form objects referencing all data needed by assembler
        A_dolfin_form = _create_dolfin_form(A_form, form_compiler_parameters,
                                            mesh, A_coefficients, A_function_spaces,
                                            cell_domains, exterior_facet_domains, interior_facet_domains)
        b_dolfin_form = _create_dolfin_form(b_form, form_compiler_parameters,
                                            mesh, b_coefficients, b_function_spaces,
                                            cell_domains, exterior_facet_domains, interior_facet_domains)

        # Check bcs
        bcs = _wrap_in_list(bcs, 'bcs', cpp.DirichletBC)

        # Call C++ assemble function
        cpp.SystemAssembler.__init__(self, A_dolfin_form, b_dolfin_form, bcs)
