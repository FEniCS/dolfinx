"""This module provides a simple way to compute the projection of a
:py:class:`Function <dolfin.functions.function.Function>` or an
:py:class:`Expression <dolfin.functions.expression.Expression>` onto a
finite element space."""

# Copyright (C) 2008-2011 Anders Logg
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# First added:  2008-07-13
# Last changed: 2011-11-15

__all__ = ['project']

# Import UFL and SWIG-generated extension module (DOLFIN C++)
import ufl
import dolfin.cpp as cpp

# Local imports
from dolfin.functions.function import *
from dolfin.functions.expression import *
from dolfin.functions.functionspace import *
from dolfin.fem.assembling import *

def project(v, V=None, bcs=None, mesh=None,
            solver_type="cg",
            preconditioner_type="default",
            form_compiler_parameters=None):
    """
    Return projection of given expression *v* onto the finite element space *V*.

    *Arguments*
        v
            a :py:class:`Function <dolfin.functions.function.Function>` or
            an :py:class:`Expression <dolfin.functions.expression.Expression>`
        bcs
            Optional argument :py:class:`list of DirichletBC
            <dolfin.fem.bcs.DirichletBC>`
        V
            Optional argument :py:class:`FunctionSpace
            <dolfin.functions.functionspace.FunctionSpace>`
        mesh
            Optional argument :py:class:`mesh <dolfin.cpp.Mesh>`.
        solver_type
            see :py:func:`solve <dolfin.fem.solving.solve>` for options.
        preconditioner_type
            see :py:func:`solve <dolfin.fem.solving.solve>` for options.
        form_compiler_parameters
            see :py:class:`Parameters <dolfin.cpp.Parameters>` for more
            information.

    *Example of usage*

        .. code-block:: python

            v = Expression("sin(pi*x[0])")
            V = FunctionSpace(mesh, "Lagrange", 1)
            Pv = project(v, V)

        This is useful for post-processing functions or expressions
        which are not readily handled by visualization tools (such as
        for example discontinuous functions).

    """

    # If trying to project an Expression
    if V is None and isinstance(v, Expression):
        if mesh is not None and isinstance(mesh, cpp.Mesh):
            V = FunctionSpaceBase(mesh, v.ufl_element())
        else:
            raise TypeError, "expected a mesh when projecting an Expression"

    # Try extracting function space if not specified
    if V is None:
        V = _extract_function_space(v, mesh)

    # Check arguments
    if not isinstance(V, FunctionSpaceBase):
        cpp.dolfin_error("projection.py",
                         "compute projection",
                         "Illegal function space for projection, not a FunctionSpace: " + str(v))

    # Define variational problem for projection
    w = TestFunction(V)
    Pv = TrialFunction(V)
    a = ufl.inner(w, Pv)*ufl.dx()
    L = ufl.inner(w, v)*ufl.dx()

    # Assemble linear system
    A, b = assemble_system(a, L, bcs=bcs,
                           form_compiler_parameters=form_compiler_parameters)

    # Solve linear system for projection
    Pv = Function(V)
    cpp.la_solve(A, Pv.vector(), b, solver_type, preconditioner_type)

    return Pv

def _extract_function_space(expression, mesh):
    """Try to extract a suitable function space for projection of
    given expression."""

    # Extract functions
    functions = ufl.algorithms.extract_coefficients(expression)

    # Extract mesh from functions
    if mesh is None:
        for f in functions:
            if isinstance(f, Function):
                mesh = f.function_space().mesh()
                if mesh is not None:
                    break
    if mesh is None:
        raise RuntimeError, "Unable to project expression, can't find a suitable mesh."

    # Create function space
    shape = expression.shape()
    if shape == ():
        V = FunctionSpace(mesh, "CG", 1)
    elif len(shape) == 1:
        V = VectorFunctionSpace(mesh, "CG", 1, dim=shape[0])
    elif len(shape) == 2:
        V = TensorFunctionSpace(mesh, "CG", 1, shape=shape)
    else:
        raise RuntimeError, "Unable to project expression, unhandled rank, shape is %s." % (shape,)

    return V
