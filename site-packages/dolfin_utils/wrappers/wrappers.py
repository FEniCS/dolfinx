"Templates for generating DOLFIN wrappers"

__author__ = "Martin Alnes (martinal@simula.no) and Anders Logg (logg@simula.no)"
__date__ = "2008-11-06 -- 2009-05-14"
__copyright__ = "Copyright (C) 2008-2009 Martin Alnes"
__license__  = "GNU GPL version 3 or any later version"

import sys, re
import ufl

from functionspace import generate_functionspace_class
from form import generate_form_class

def strip_chars(s):
    r = re.compile("([(),. -\"']+)")
    s = r.subn("_", s)
    s = s[0].strip("_")
    return s

comment = "// DOLFIN wrappers"

stl_includes = """\
// Standard library includes
#include <string>"""

dolfin_includes = """\
// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>"""

class UFCFormNames:
    "Encapsulation of the names related to a generated UFC form."
    def __init__(self, name, coefficient_names, ufc_form_classname, ufc_finite_element_classnames, ufc_dof_map_classnames):
        """Arguments:

        @param name:
            Name of form (e.g. 'a', 'L', 'M').
        @param coefficient_names:
            List of names of form coefficients (e.g. 'f', 'g').
        @param ufc_form_classname:
            Name of ufc::form subclass.
        @param ufc_finite_element_classnames:
            List of names of ufc::finite_element subclasses (length rank + num_coefficients).
        @param ufc_dof_map_classnames:
            List of names of ufc::dof_map subclasses (length rank + num_coefficients).
        """
        assert len(coefficient_names) <= len(ufc_dof_map_classnames)
        assert len(ufc_finite_element_classnames) == len(ufc_dof_map_classnames)

        self.num_coefficients              = len(coefficient_names)
        self.rank                          = len(ufc_finite_element_classnames) - self.num_coefficients
        self.name                          = name
        self.coefficient_names             = coefficient_names
        self.ufc_form_classname            = ufc_form_classname
        self.ufc_finite_element_classnames = ufc_finite_element_classnames
        self.ufc_dof_map_classnames        = ufc_dof_map_classnames

    def __str__(self):
        s = "UFCFormNames instance:\n"
        s += "rank:                      %d\n" % self.rank
        s += "num_coefficients:          %d\n" % self.num_coefficients
        s += "name:                      %s\n" % self.name
        s += "coefficient_names:         %s\n" % str(self.coefficient_names)
        s += "ufc_form_classname:        %s\n" % str(self.ufc_form_classname)
        s += "finite_element_classnames: %s\n" % str(self.ufc_finite_element_classnames)
        s += "ufc_dof_map_classnames:    %s\n" % str(self.ufc_dof_map_classnames)
        return s

def generate_dolfin_classes(prefix, form_names, common_space):
    """Generate code for all dolfin wrapper classes.

    @param prefix:
        String, prefix for all form names.
    @param form_names:
        List of UFCFormNames instances for each form to wrap.
    @param common_space:
        Tuple (form_index, space_index) of common function space if any, otherwise None.
    """

    # Collection of code blocks
    blocks = []

    # Check if naming forms by rank (BilinearForm etc) makes sense
    name_forms_by_rank = True
    ranks = [fn.rank for fn in form_names]
    for r in range(min(ranks), max(ranks) + 1):
        if ranks.count(r) > 1:
            name_forms_by_rank = False

    class_typedefs = []

    # Build list of unique coefficient names in forms
    # NB! This will break down if multiple forms define
    # different coefficients using the same name, e.g.
    # if coefficient_names are auto-generated like "w%d".
    coefficient_names = set()
    for fn in form_names:
        coefficient_names.update(fn.coefficient_names)
    coefficient_names = sorted(list(coefficient_names))

    # Generate CoefficientReference classes
    #for name in coefficient_names:
    #    coefficient_reference_classname = "%sCoefficientReference_%s" % (prefix, name)
    #    code = generate_coefficient_reference_class(coefficient_reference_classname, name)
    #    blocks.append(code)
    # Currently using a single fixed class instead:
    #code = coefficient_reference_code
    #blocks.append(code)

    # Generate CoefficientSet class
    #coefficient_set_classname = "%sCoefficientSet" % prefix
    #code = generate_coefficient_set_class(coefficient_set_classname, coefficient_names)
    #blocks.append(code)

    # Match ufc classnames with argument names (independently
    # of SFC or FFC naming convention outside this function)
    # NB! This will break down if multiple forms define
    # different coefficients using the same name, e.g.
    # if coefficient_names are auto-generated like "w%d".
    ufc_finite_element_classnames = {}
    ufc_dof_map_classnames = {}
    for fn in form_names:
        for i, name in enumerate(fn.coefficient_names):
            ufc_finite_element_classnames[name] = fn.ufc_finite_element_classnames[fn.rank + i]
            ufc_dof_map_classnames[name] = fn.ufc_dof_map_classnames[fn.rank + i]

    # Generate FunctionSpace subclasses for coefficients independently of forms
    global_coefficientspace_classnames = {}
    for name in coefficient_names:
        global_coefficientspace_classnames[name] = "%sCoefficientSpace_%s" % (prefix, name)
        fe = ufc_finite_element_classnames[name]
        dm = ufc_dof_map_classnames[name]
        code = generate_functionspace_class(global_coefficientspace_classnames[name], fe, dm)
        blocks.append(code)

    # Handle each form
    for fn in form_names:

        # Form class name
        classname = "%sForm_%s" % (prefix, fn.name)
        if name_forms_by_rank and fn.rank <= 3:
            suffix = {0: "Functional", 1: "LinearForm", 2: "BilinearForm", 3: "TrilinearForm"}[fn.rank]
            class_typedefs.append((classname, "%s%s" % (prefix, suffix)))

        # Class names of generated classes, named by form and numbering
        functionspace_classnames = ["%s_FunctionSpace_%d"  % (classname, i) for i in range(fn.rank + fn.num_coefficients)]
        coefficient_classnames   = ["%s_Coefficient_%s"   % (classname, n) for n in fn.coefficient_names]
        #coefficient_classnames   = ["%s_Coefficient%d"   % (classname, i) for i in range(fn.num_coefficients)]

        # Class names for typedefs in class namespace
        coefficientspace_classnames = ["CoefficientSpace_%s" % n for n in fn.coefficient_names]
        basespace_classnames = ["FunctionSpace_%d" % i for i in range(fn.rank)]

        # Special treatment for bilinear and linear forms
        if fn.rank == 1:
            basespace_classnames[0] = "TestSpace"
        elif fn.rank == 2:
            basespace_classnames[0] = "TestSpace"
            basespace_classnames[1] = "TrialSpace"

        # Generate FunctionSpace subclasses
        for i in range(fn.rank):
            code = generate_functionspace_class(functionspace_classnames[i],
                                                fn.ufc_finite_element_classnames[i], fn.ufc_dof_map_classnames[i])
            blocks.append(code)

        # Old behaviour TODO: Can we remove this?
        if False:
            # Generate FunctionSpace subclasses for coefficients
            for j in range(fn.num_coefficients):
                i = fn.rank + j
                code = generate_functionspace_class(functionspace_classnames[i],
                                                    fn.ufc_finite_element_classnames[i], fn.ufc_dof_map_classnames[i])
        else:
            # Generate typedefs for FunctionSpace subclasses for coefficients
            for i in range(fn.num_coefficients):
                global_name = global_coefficientspace_classnames[fn.coefficient_names[i]]
                local_name = functionspace_classnames[fn.rank + i]
                code = "typedef %s %s;" % (global_name, local_name)
                blocks.append(code)

        # Generate Coefficient subclasses
        #for i in range(fn.num_coefficients):
        #    code = generate_coefficient_class(coefficient_classnames[i], functionspace_classnames[fn.rank+i], i, fn.coefficient_names[i])
        #    blocks.append(code)

        # Generate Form subclass
        formclass = generate_form_class(classname, fn.ufc_form_classname,
                                        functionspace_classnames, basespace_classnames, coefficientspace_classnames,
                                        coefficient_classnames, fn.coefficient_names)
        blocks.append(formclass)

    # Handle common function space
    if common_space is not None:
        #class_typedefs.append(("Form_%d_FunctionSpace_%d" % common_space, "FunctionSpace"))
        form_index, space_index = common_space
        fn = form_names[form_index]
        formclassname = "%sForm_%s" % (prefix, fn.name) # NB! Should match form classname constructed in loop above
        spaceclassname = basespace_classnames[space_index]
        spaceclassname = "%s::%s" % (formclassname, spaceclassname)
        class_typedefs.append((spaceclassname, "FunctionSpace"))

    # Add class typedefs for optional FooBilinearForm naming
    if class_typedefs:
        code = "// Class typedefs\n"
        code += "\n".join("typedef %s %s;" % (a, b) for (a, b) in class_typedefs)
        blocks.append(code)

    # Join blocks together
    code = "\n\n".join(blocks)
    return code

def generate_dolfin_code(prefix, header, form_names, common_space=None, add_guards=False):
    """Generate complete dolfin wrapper code with given generated names.

    @param prefix:
        String, prefix for all form names.
    @param header:
        Code that will be inserted at the top of the file.
    @param form_names:
        List of UFCFormNames instances for each form to wrap.
    @param common_space:
        Tuple (form_index, space_index) of common function space if any, otherwise None.
    @param add_guards:
        True iff guards (ifdefs) should be added
    """

    code = ""

    # Generate guardnames
    guardname = ("%s_h" % prefix).upper()
    preguard = "#ifndef %s\n#define %s\n" % (guardname, guardname)
    postguard = "#endif\n"

    # Using prefix as namespace
    namespace = prefix

    # Generate classes
    dolfin_classes = generate_dolfin_classes("", form_names, common_space)

    # Add pre guard
    if add_guards:
        code += preguard + "\n"

    # Add code
    code += "\n".join((comment,
                       header,
                       stl_includes,
                       "",
                       dolfin_includes,
                       "\nnamespace %s\n{\n" % namespace,
                       dolfin_classes,
                       "\n} // namespace %s" % namespace))

    # Add post guard
    if add_guards:
        code += "\n" + postguard + "\n"

    return code

# ------------------------------------------------------ Test code below this line

# TODO: We can add typedefs in SFC to avoid this remapping of names, or better FFC can start reusing elements to reduce its code size.

# TODO: This code should be in SFC
def _generate_dolfin_code_sfc_way(form_datas, header, prefix, fcprefix):
    "Example dolfin code wrapper code generation."

    # Define generated element classnames, unique for each unique element
    _unique_elements = sorted(set(e for fd in form_datas for e in fd.unique_elements))
    unique_ufc_finite_element_classnames = dict((e, "%s_finite_element_%s" % (fcprefix, strip_chars(repr(e)))) for e in _unique_elements)
    unique_ufc_dof_map_classnames        = dict((e, "%s_dof_map_%s"        % (fcprefix, strip_chars(repr(e)))) for e in _unique_elements)

    # Build UFCFormNames instances
    form_names = []
    for fd in form_datas:
        # Define generated form classname
        ufc_form_classname = "%s_%s_form_%s" % (fcprefix, prefix, fd.name)

        # Create ordered lists of element classnames
        ufc_finite_element_classnames = [unique_ufc_finite_element_classnames[e] for e in fd.elements]
        ufc_dof_map_classnames        = [unique_ufc_dof_map_classnames[e]        for e in fd.elements]

        form_names.append(UFCFormNames(fd.name, fd.function_names, ufc_form_classname, ufc_finite_element_classnames, ufc_dof_map_classnames))

    return generate_dolfin_code(prefix, header, form_names, (0,0), True)

# TODO: This code should be in FFC
def _generate_dolfin_code_ffc_way(form_datas, header, prefix, fcprefix):
    "Example dolfin code wrapper code generation."
    # NB! This code was written assuming UFL FormData instances
    # TODO: Use FFC naming conventions for ufc classes here

    # Build UFCFormNames instances
    form_names = []
    for fd in form_datas:
        # Define generated form classnames
        ufc_form_classname = "%s_%s_form_%s" % (fcprefix, prefix, fd.name)

        # Create ordered lists of element classnames
        ufc_finite_element_classnames = ["%s_ufc_finite_element_%d" % (ufc_form_classname, i) for i in range(fd.rank + fd.num_functions)]
        ufc_dof_map_classnames        = ["%s_ufc_dof_map_%d"        % (ufc_form_classname, i) for i in range(fd.rank + fd.num_functions)]

        form_names.append(UFCFormNames(fd.name, fd.function_names, ufc_form_classname, ufc_finite_element_classnames, ufc_dof_map_classnames))

    return generate_dolfin_code(prefix, header, form_names, (0,0), True)

def _copen(filename):
    "Open a file or the console for writing."
    return open(filename, "w") if filename else sys.stdout

def _write_dolfin_code(uflfilename, hfilename, prefix, fcprefix):
    "Example code using dolfin code wrapper generators on forms from a UFL form file."
    # Load UFL forms
    forms = ufl.algorithms.load_forms(uflfilename)
    form_datas = [f.form_data() for f in forms]

    header = "// Example of generated dolfin wrappers"

    # Generate dolfin wrapper code
    code = _generate_dolfin_code_sfc_way(form_datas, header, prefix, fcprefix)
    code = _generate_dolfin_code_ffc_way(form_datas, header, prefix, fcprefix)

    # Write to file or console
    f = _copen(hfilename)
    f.write(code)
    f.write("\n")
    if hfilename: f.close()

if __name__ == "__main__":
    uflfilename = "../../../demo/pde/curl-curl/cpp/CurrentDensity.ufl"
    hfilename = None #"Foobar.h"
    prefix = "MyPrefix"
    fcprefix = "sfc"
    _write_dolfin_code(uflfilename, hfilename, prefix, fcprefix)
