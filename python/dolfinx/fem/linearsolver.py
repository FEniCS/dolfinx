# -*- coding: utf-8 -*-
# Copyright (C) 2020 JÃ¸rgen S. Dokken
#
# This file is part of DOLFINX (https://www.fenicsproject.org)
#
# SPDX-License-Identifier:    LGPL-3.0-or-later
import typing

from petsc4py import PETSc
from ufl import form
from dolfinx import fem


class LinearSolver():

    def __init__(self, a: form.Form, L: form.Form, bcs: typing.List[fem.DirichletBC] = [],
                 petsc_options={}, form_compiler_parameters={}, jit_parameters={}):
        """
        Initialize solver for a linear variational problem.
        a:
            A bi-linear UFL form, the left hand side of the variational problem.

        L:
            A linear UFL form , the right hand side of the variational problem.

        bcs:
            A list of Dirichlet boundary conditions.

        petsc_options:
            Parameters that is passed to the linear algebra backend PETSc.
            For available choices for the 'petsc_options' kwarg, see the
            `PETSc-documentation <https://www.mcs.anl.gov/petsc/documentation/index.html>`.

        form_compiler_parameters:
            Parameters used in FFCX compilation of this form. Run `ffcx --help` at
            the commandline to see all available options. Takes priority over all
            other parameter values, except for `scalar_type` which is determined by
            DOLFINX.

        jit_parameters:
            Parameters used in CFFI JIT compilation of C code generated by FFCX.
            See `python/dolfinx/jit.py` for all available
            parameters. Takes priority over all other parameter values.

        .. code-block:: python

            solver = LinearSolver(a, L, [bc0, bc1],
                                  petsc_options={"ksp_type": "preonly", "pc_type": "lu"})

        """
        self.a = fem.Form(a, form_compiler_parameters=form_compiler_parameters,
                          jit_parameters=jit_parameters)
        self.A = fem.create_matrix(self.a)

        self.L = fem.Form(L, form_compiler_parameters=form_compiler_parameters,
                          jit_parameters=jit_parameters)
        self.b = fem.create_vector(self.L)

        # Extract function space from TrialFunction (which is at the end of the argument
        # list as it is numbered as 1, while the Test function is numbered as 0)
        self.u = fem.Function(a.arguments()[-1].ufl_function_space())
        self.bcs = bcs

        self.solver = PETSc.KSP().create(self.u.function_space.mesh.mpi_comm())
        self.solver.setOperators(self.A)
        # Give unique prefix linked to the dolfinx.fem.Function's unique ID.
        self.solver.setOptionsPrefix("dolfinx_solve_{0:d}".format(self.u.id))
        opts = PETSc.Options()
        opts.prefixPush("dolfinx_solve_{0:d}".format(self.u.id))
        for k, v in petsc_options.items():
            opts[k] = v
        opts.prefixPop()
        self.solver.setFromOptions()

    def solve(self):
        """
        Solves the linear variational problem using PETSc.

        """
        # Assemble lhs
        self.A.zeroEntries()
        fem.assemble_matrix(self.A, self.a, bcs=self.bcs)
        self.A.assemble()

        # Assemble rhs
        with self.b.localForm() as loc:
            loc.set(0)
        fem.assemble_vector(self.b, self.L)

        # Apply boundary conditions
        fem.apply_lifting(self.b, [self.a], [self.bcs])
        self.b.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
        fem.set_bc(self.b, self.bcs)

        # Solve linear algebra problem using PETSc
        self.solver.solve(self.b, self.u.vector)
        self.u.vector.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)
        return self.u
