# -*- coding: utf-8 -*-
# Copyright (C) 2021 JÃ¸rgen S. Dokken
#
# This file is part of DOLFINX (https://www.fenicsproject.org)
#
# SPDX-License-Identifier:    LGPL-3.0-or-later

from typing import List
import ufl
from petsc4py import PETSc
from dolfinx import fem, cpp
import mpi4py


class NonlinearProblem:
    """Nonlinear problem class for solving the non-linear problem
    F(u, v) = 0 for all v in V

    """

    def __init__(self, F: ufl.form.Form, u: fem.Function, bcs: List[fem.DirichletBC] = [],
                 form_compiler_parameters={}, jit_parameters={}):
        """Initialize class that sets up structures for solving the non-linear problem using Newton's method, 
        dF/du(u) du = -F(u)

        Parameters
        ----------
        F
            The PDE residual F(u, v)
        u
            The unknown
        bcs
            List of Dirichlet boundary conditions

        form_compiler_parameters
            Parameters used in FFCX compilation of this form. Run `ffcx --help` at
            the commandline to see all available options. Takes priority over all
            other parameter values, except for `scalar_type` which is determined by
            DOLFINX.

        jit_parameters
            Parameters used in CFFI JIT compilation of C code generated by FFCX.
            See `python/dolfinx/jit.py` for all available parameters.
            Takes priority over all other parameter values.

        .. code-block:: python
            problem = LinearProblem(F, u, [bc0, bc1])
        """
        V = u.function_space
        du = ufl.TrialFunction(V)
        self.L = fem.form.Form(F, form_compiler_parameters=form_compiler_parameters, jit_parameters=jit_parameters)
        # Create the Jacobian matrix, dF/du
        self.a = fem.form.Form(ufl.derivative(F, u, du), form_compiler_parameters=form_compiler_parameters,
                               jit_parameters=jit_parameters)
        self.bcs = bcs

        # Create matrix and vector to be used for assembly
        # of the non-linear problem
        self.matrix = fem.create_matrix(self.a)
        self.vector = fem.create_vector(self.L)

    def form(self, x: PETSc.Vec):
        """
        This function is called before the residual or Jacobian is computed.
        This is usually used to update ghost values.
        Input: 
           x: The vector containing the latest solution
        """
        x.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)

    def F(self, x: PETSc.Vec, b: PETSc.Vec):
        """Assemble the residual F into the vector b. 
        Input:
           x: The vector containing the latest solution
           b: Vector to assemble the residual into
        """
        # Reset the residual vector
        with b.localForm() as b_local:
            b_local.set(0.0)
        fem.assemble_vector(b, self.L)
        # Apply boundary condition
        fem.apply_lifting(b, [self.a], [self.bcs], [x], -1.0)
        b.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
        fem.set_bc(b, self.bcs, x, -1.0)

    def J(self, x: PETSc.Vec, A: PETSc.Mat):
        """Assemble the Jacobian matrix.
        Input:
          - x: The vector containing the latest solution
          - A: The matrix to assemble the Jacobian into
        """
        A.zeroEntries()
        fem.assemble_matrix(A, self.a, self.bcs)
        A.assemble()


class NewtonSolver(cpp.nls.NewtonSolver):
    def __init__(self, comm: mpi4py.MPI.Intracomm, problem: NonlinearProblem):
        """
        Create a Newton solver for a given MPI communicator and non-linear problem.
        """
        super().__init__(comm)
        self.setF(problem.F, problem.vector)
        self.setJ(problem.J, problem.matrix)
        self.set_form(problem.form)

    def solve(self, u: fem.Function):
        """
        Solve non-linear problem into function u.
        Returns the number of iterations and if the solver converged
        """
        n, converged = super().solve(u.vector)
        cpp.la.scatter_forward(u.x)
        return n, converged
