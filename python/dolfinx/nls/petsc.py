# Copyright (C) 2021-2025 JÃ¸rgen S. Dokken
#
# This file is part of DOLFINx (https://www.fenicsproject.org)
#
# SPDX-License-Identifier:    LGPL-3.0-or-later
"""Methods for solving nonlinear equations using PETSc solvers."""

from __future__ import annotations

import itertools
import typing
from functools import partial

from mpi4py import MPI
from petsc4py import PETSc

import dolfinx.la
import ufl
from dolfinx.fem.bcs import bcs_by_block as _bcs_by_block
from dolfinx.fem.forms import extract_function_spaces as _extract_spaces

if typing.TYPE_CHECKING:
    import dolfinx

    assert dolfinx.has_petsc4py

    from dolfinx.fem.problem import NonlinearProblem

import types

from dolfinx import cpp as _cpp
from dolfinx import fem
from dolfinx.fem.forms import form as _create_form
from dolfinx.fem.petsc import (
    apply_lifting,
    assemble_vector,
    create_matrix,
    create_vector,
    set_bc,
)

__all__ = ["NewtonSolver", "SNESSolver", "create_snes_solver"]


class NewtonSolver(_cpp.nls.petsc.NewtonSolver):
    def __init__(self, comm: MPI.Intracomm, problem: NonlinearProblem):
        """A Newton solver for non-linear problems."""
        super().__init__(comm)

        # Create matrix and vector to be used for assembly
        # of the non-linear problem
        self._A = create_matrix(problem.a)
        self.setJ(problem.J, self._A)
        self._b = create_vector(problem.L)
        self.setF(problem.F, self._b)
        self.set_form(problem.form)

    def __del__(self):
        self._A.destroy()
        self._b.destroy()

    def solve(self, u: fem.Function):
        """Solve non-linear problem into function u. Returns the number
        of iterations and if the solver converged."""
        n, converged = super().solve(u.x.petsc_vec)
        u.x.scatter_forward()
        return n, converged

    @property
    def A(self) -> PETSc.Mat:  # type: ignore
        """Jacobian matrix"""
        return self._A

    @property
    def b(self) -> PETSc.Vec:  # type: ignore
        """Residual vector"""
        return self._b

    def setP(self, P: types.FunctionType, Pmat: PETSc.Mat):  # type: ignore
        """
        Set the function for computing the preconditioner matrix

        Args:
            P: Function to compute the preconditioner matrix
            Pmat: Matrix to assemble the preconditioner into

        """
        super().setP(P, Pmat)


class SNESSolver:
    def __init__(
        self,
        F: typing.Union[dolfinx.fem.Form, ufl.form.Form],
        u: typing.Union[dolfinx.fem.Function, list[dolfinx.fem.Function]],
        bcs: typing.Optional[list[dolfinx.fem.DirichletBC]] = None,
        J: typing.Optional[typing.Union[dolfinx.fem.Form, ufl.form.Form]] = None,
        P: typing.Optional[typing.Union[dolfinx.fem.Form, ufl.form.Form]] = None,
        mat_kind: typing.Optional[typing.Union[str, typing.Iterable[typing.Iterable[str]]]] = None,
        vec_kind: typing.Optional[str] = None,
        form_compiler_options: typing.Optional[dict] = None,
        jit_options: typing.Optional[dict] = None,
        snes_options: typing.Optional[dict] = None,
    ):
        """Class for interfacing with SNES.

        Solves problems of the form :math:`F_i(u, v) = 0, i=0,...N\\ \\forall v \\in V`
        where :math:`u=(u_0,...,u_N), v=(v_0,...,v_N)` using PETSc SNES as the non-linear solver.

        Args:
            F: List of PDE residuals :math:`F_i`.
            u: List of unknowns of the block system.
            bcs: List of Dirichlet boundary conditions.
            J: Rectangular array of bi-linear forms representing the
                Jacobian :math:`J_ij = dF_i/du_j`.
            P: Rectangular array of bi-linear forms representing the preconditioner.
            mat_kind: The PETSc matrix type (``MatType``).
                See :func:`dolfinx.fem.petsc.create_matrix` for more information.
            vec_kind: The PETSc vector type (``VecType``).
                See :func:`dolfinx.fem.petsc.create_vector` for more information.
            form_compiler_options: Options used in FFCx
                compilation of this form. Run ``ffcx --help`` at the
                command line to see all available options.
            jit_options: Options used in CFFI JIT compilation of C
                code generated by FFCx. See ``python/dolfinx/jit.py``
                for all available options. Takes priority over all other
                option values.
            snes_options: Options to pass to the PETSc SNES object.
        """

        self._u = u
        self._snes, self._x = create_snes_solver(
            F,
            self._u,
            bcs,
            J,
            P,
            mat_kind=mat_kind,
            vec_kind=vec_kind,
            form_compiler_options=form_compiler_options,
            jit_options=jit_options,
        )

        # Set PETSc options
        if snes_options is not None:
            problem_prefix = f"snes_{id(self)}"
            self._snes.setOptionsPrefix(problem_prefix)

            opts = PETSc.Options()  # type: ignore
            opts.prefixPush(problem_prefix)
            for k, v in snes_options.items():
                opts[k] = v
            self._snes.setFromOptions()
            opts.prefixPop()

            # Delete options from handler post setting
            for k in snes_options.keys():
                del opts[k]

    def solve(self) -> tuple[PETSc.Vec, int, int]:  # type: ignore
        """Solve the problem and update the solution in the problem instance.

        Returns:
            The solution, convergence reason and number of iterations
        """

        # Move current iterate into the work array.
        dolfinx.fem.petsc.assign(self._u, self._x)

        # Solve problem
        self._snes.solve(None, self._x)

        # Move solution back to function
        dolfinx.fem.petsc.assign(self._x, self._u)

        converged_reason = self._snes.getConvergedReason()
        return self._x, converged_reason, self._snes.getIterationNumber()

    def __del__(self):
        self._snes.destroy()
        self._x.destroy()

    @property
    def snes(self) -> PETSc.SNES:  # type: ignore
        return self._snes

    @property
    def copy_function_to_vec(self):
        return self._copy_function_to_vec

    @property
    def copy_vec_to_function(self):
        return self._copy_vec_to_function


def F_standard(
    u: dolfinx.fem.Function,
    residual: dolfinx.fem.Form,
    jacobian: dolfinx.fem.Form,
    bcs: list[dolfinx.fem.DirichletBC],
    _snes: PETSc.SNES,  # type: ignore
    x: PETSc.Vec,  # type: ignore
    F: PETSc.Vec,  # type: ignore
):
    """Assemble the residual into the vector `F`.

    Args:
        u: Function tied to the solution vector within the residual and Jacobian.
        residual: Form of the residual.
        jacobian: Form of the Jacobian.
        bcs: List of Dirichlet boundary conditions.
        _snes: The solver instance.
        x: The vector containing the point to evaluate the residual at.
        F: Vector to assemble the residual into.
    """
    x.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)
    dolfinx.fem.petsc.assign(x, u)
    with F.localForm() as f_local:
        f_local.set(0.0)
    assemble_vector(F, residual)
    apply_lifting(F, [jacobian], bcs=[bcs], x0=[x], alpha=-1.0)
    F.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)  # type: ignore
    set_bc(F, bcs, x, -1.0)


def assemble_jacobian(
    u: dolfinx.fem.Function,
    jacobian: dolfinx.fem.Form,
    preconditioner: typing.Optional[dolfinx.fem.Form],
    bcs: list[dolfinx.fem.DirichletBC],
    _snes: PETSc.SNES,  # type: ignore
    x: PETSc.Vec,  # type: ignore
    J: PETSc.Mat,  # type: ignore
    P: PETSc.Mat,  # type: ignore
):
    """Assemble the Jacobian matrix and preconditioner.

    Args:
        u: Function tied to the solution vector within the residual and jacobian
        jacobian: Form of the Jacobian
        preconditioner: Form of the preconditioner
        bcs: List of Dirichlet boundary conditions
        _snes: The solver instance
        x: The vector containing the point to evaluate at
        J: Matrix to assemble the Jacobian into
        P: Matrix to assemble the preconditioner into
    """
    # Copy existing soultion into the function used in the residual and Jacobian
    if x.getType() != "nest":
        x.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)
    else:
        for x_sub in x.getNestSubVecs():
            x_sub.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)
    dolfinx.fem.petsc.assign(x, u)

    # Assemble Jacobian
    J.zeroEntries()
    dolfinx.fem.petsc.assemble_matrix(J, jacobian, bcs, diag=1.0)  # type: ignore
    J.assemble()
    if preconditioner is not None:
        P.zeroEntries()
        dolfinx.fem.petsc.assemble_matrix(P, preconditioner, bcs, diag=1.0)  # type: ignore
        P.assemble()


def F_block(
    u: list[dolfinx.fem.Function],
    residual: list[dolfinx.fem.Form],
    jacobian: list[list[dolfinx.fem.Form]],
    bcs: list[dolfinx.fem.DirichletBC],
    _snes: PETSc.SNES,  # type: ignore
    x: PETSc.Vec,  # type: ignore
    F: PETSc.Vec,  # type: ignore
):
    """Assemble the residual into the vector F.

    Args:
        u: List of functions tied to the solution vector within the residual and jacobian
        residual: List of forms of the residual
        jacobian: List of list of forms of the Jacobian
        bcs: List of Dirichlet boundary conditions
        _snes: The solver instance
        x: The vector containing the latest solution
        F: Vector to assemble the residual into
    """
    assert x.getType() != "nest", "Vector x should be non-nested"
    assert F.getType() != "nest", "Vector F should be non-nested"
    with F.localForm() as f_local:
        f_local.set(0.0)
    x.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)
    dolfinx.fem.petsc.assign(x, u)

    # Assign blocks variable to the vectors
    maps = [
        (
            form.function_spaces[0].dofmaps(0).index_map,
            form.function_spaces[0].dofmaps(0).index_map_bs,
        )
        for form in residual
    ]
    off_owned = tuple(
        itertools.accumulate(maps, lambda off, m: off + m[0].size_local * m[1], initial=0)
    )
    off_ghost = tuple(
        itertools.accumulate(
            maps, lambda off, m: off + m[0].num_ghosts * m[1], initial=off_owned[-1]
        )
    )
    F.setAttr("_blocks", (off_owned, off_ghost))
    x.setAttr("_blocks", (off_owned, off_ghost))

    assemble_vector(F, residual)
    bcs1 = dolfinx.fem.bcs_by_block(dolfinx.fem.extract_function_spaces(jacobian, 1), bcs)
    dolfinx.fem.petsc.apply_lifting(
        F,
        jacobian,
        bcs=bcs1,
        x0=x,
        alpha=-1.0,
    )
    F.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
    bcs0 = dolfinx.fem.bcs_by_block(dolfinx.fem.extract_function_spaces(residual), bcs)
    dolfinx.fem.petsc.set_bc(F, bcs0, x0=x, alpha=-1.0)
    F.ghostUpdate(PETSc.InsertMode.INSERT_VALUES, PETSc.ScatterMode.FORWARD)


def F_nest(
    u: list[dolfinx.fem.Function],
    residual: list[dolfinx.fem.Form],
    jacobian: list[list[dolfinx.fem.Form]],
    bcs: list[dolfinx.fem.DirichletBC],
    _snes: PETSc.SNES,  # type: ignore
    x: PETSc.Vec,  # type: ignore
    F: PETSc.Vec,  # type: ignore
):
    """Assemble the residual into the vector F.

    Args:
        u: List of functions tied to the solution vector within the residual and jacobian
        residual: List of forms of the residual
        jacobian: List of list of forms of the Jacobian
        bcs: List of Dirichlet boundary conditions
        _snes: The solver instance
        x: The vector containing the latest solution
        F: Vector to assemble the residual into
    """
    assert x.getType() == "nest" and F.getType() == "nest"
    for x_sub in x.getNestSubVecs():
        x_sub.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)
    dolfinx.fem.petsc.assign(x, u)
    bcs1 = _bcs_by_block(_extract_spaces(jacobian, 1), bcs)
    sub_vectors = x.getNestSubVecs()
    for L, F_sub, a in zip(residual, F.getNestSubVecs(), jacobian):
        with F_sub.localForm() as F_sub_local:
            F_sub_local.set(0.0)
        assemble_vector(F_sub, L)
        apply_lifting(F_sub, a, bcs=bcs1, x0=sub_vectors, alpha=-1.0)
        F_sub.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)  # type: ignore
    # Set bc value in RHS
    bcs0 = _bcs_by_block(_extract_spaces(residual), bcs)
    for F_sub, bc, x_sub in zip(F.getNestSubVecs(), bcs0, sub_vectors):
        set_bc(F_sub, bc, x_sub, -1.0)

    # Must assemble F here in the case of nest matrices
    F.assemble()


def create_snes_solver(
    F: typing.Union[dolfinx.fem.Form, ufl.form.Form, list[dolfinx.fem.Form], list[ufl.form.Form]],
    u: typing.Union[dolfinx.fem.Function, list[dolfinx.fem.Function]],
    bcs: typing.Optional[list[dolfinx.fem.DirichletBC]] = None,
    J: typing.Optional[
        typing.Union[
            dolfinx.fem.Form, ufl.form.Form, list[list[dolfinx.fem.Form]], list[list[ufl.Form]]
        ]
    ] = None,
    P: typing.Optional[
        typing.Union[
            dolfinx.fem.Form, ufl.form.Form, list[list[dolfinx.fem.Form]], list[list[ufl.Form]]
        ]
    ] = None,
    mat_kind: typing.Optional[typing.Union[str, typing.Iterable[typing.Iterable[str]]]] = None,
    vec_kind: typing.Optional[str] = None,
    form_compiler_options: typing.Optional[dict] = None,
    jit_options: typing.Optional[dict] = None,
) -> tuple[PETSc.SNES, PETSc.Vec]:  # type: ignore
    """Create a PETSc SNES solver instance and a vector to store solutions in.

    Solves problems of the form :math:`F_i(u, v) = 0, i=0,...N\\ \\forall v \\in V`
    where :math:`u=(u_0,...,u_N), v=(v_0,...,v_N)` using PETSc SNES as the non-linear solver.

    Note:
        The user is responsible for the destruction of the returned objects.

    Args:
        F: List of PDE residuals :math:`F_i`.
        u: List of unknowns of the block system.
        bcs: List of Dirichlet boundary conditions.
        J: Rectangular array of bi-linear forms representing the
            Jacobian :math:`J_ij = dF_i/du_j`.
        P: Rectangular array of bi-linear forms representing the preconditioner.
        mat_kind: The PETSc matrix type (``MatType``).
            See :func:`dolfinx.fem.petsc.create_matrix` for more information.
        vec_kind: The PETSc vector type (``VecType``).
            See :func:`dolfinx.fem.petsc.create_vector` for more information.
        form_compiler_options: Options used in FFCx
            compilation of this form. Run ``ffcx --help`` at the
            command line to see all available options.
        jit_options: Options used in CFFI JIT compilation of C
            code generated by FFCx. See ``python/dolfinx/jit.py``
            for all available options. Takes priority over all other
            option values.
    Returns:
        A PETSc SNES solver instance and a vector to store solutions in.
    """
    # Set default values if not supplied
    bcs = [] if bcs is None else bcs
    form_compiler_options = {} if form_compiler_options is None else form_compiler_options
    jit_options = {} if jit_options is None else jit_options

    # Compile residual and Jacobian forms
    residual = _create_form(F, form_compiler_options=form_compiler_options, jit_options=jit_options)
    if J is None:
        J = fem.forms.compute_jacobian(F, u)
    jacobian = _create_form(J, form_compiler_options=form_compiler_options, jit_options=jit_options)

    # Create PETSc structures for the residual, Jacobian and solution vector
    A = create_matrix(jacobian, kind=mat_kind)
    b = create_vector(residual, kind=vec_kind)
    x = create_vector(residual, kind=vec_kind)

    # Compile and create preconditioner structure if provided
    preconditioner = None
    P_mat = None
    if P is not None:
        preconditioner = _create_form(
            P, form_compiler_options=form_compiler_options, jit_options=jit_options
        )
        P_mat = create_matrix(preconditioner, kind=mat_kind)

    # Create the SNES solver and attach the corresponding jacobian and residual
    # computation functions
    snes = PETSc.SNES().create(comm=A.comm)  # type: ignore
    snes.setJacobian(partial(assemble_jacobian, u, jacobian, preconditioner, bcs), A, P_mat)

    if A.getType() == PETSc.Mat.Type.NEST:
        # Check for SNES consistency
        assert b.getType() == PETSc.Vec.Type.NEST
        snes.setFunction(partial(F_nest, u, residual, jacobian, bcs), b)
    elif isinstance(residual, dolfinx.fem.Form):
        snes.setFunction(partial(F_standard, u, residual, jacobian, bcs), b)  # type: ignore
    else:
        snes.setFunction(partial(F_block, u, residual, jacobian, bcs), b)
    return snes, x
