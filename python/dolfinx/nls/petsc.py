# Copyright (C) 2021-2025 JÃ¸rgen S. Dokken
#
# This file is part of DOLFINx (https://www.fenicsproject.org)
#
# SPDX-License-Identifier:    LGPL-3.0-or-later
"""Methods for solving nonlinear equations using PETSc solvers."""

from __future__ import annotations

import itertools
import typing
from functools import partial

from mpi4py import MPI
from petsc4py import PETSc

import numpy as np
import numpy.typing as npt

import ufl
from dolfinx.fem.bcs import bcs_by_block as _bcs_by_block
from dolfinx.fem.forms import extract_function_spaces as _extract_spaces

if typing.TYPE_CHECKING:
    import dolfinx

    assert dolfinx.has_petsc4py

    from dolfinx.fem.problem import NonlinearProblem

import types

from dolfinx import cpp as _cpp
from dolfinx import fem
from dolfinx.fem.forms import form as _create_form
from dolfinx.fem.petsc import (
    apply_lifting,
    assemble_matrix,
    assemble_vector,
    assign,
    create_matrix,
    create_vector,
    set_bc,
)

__all__ = ["NewtonSolver", "SNESSolver", "create_snes_solver"]


class NewtonSolver(_cpp.nls.petsc.NewtonSolver):
    def __init__(self, comm: MPI.Intracomm, problem: NonlinearProblem):
        """A Newton solver for non-linear problems."""
        super().__init__(comm)

        # Create matrix and vector to be used for assembly
        # of the non-linear problem
        self._A = create_matrix(problem.a)
        self.setJ(problem.J, self._A)
        self._b = create_vector(problem.L)
        self.setF(problem.F, self._b)
        self.set_form(problem.form)

    def __del__(self):
        self._A.destroy()
        self._b.destroy()

    def solve(self, u: fem.Function):
        """Solve non-linear problem into function u. Returns the number
        of iterations and if the solver converged."""
        n, converged = super().solve(u.x.petsc_vec)
        u.x.scatter_forward()
        return n, converged

    @property
    def A(self) -> PETSc.Mat:  # type: ignore
        """Jacobian matrix"""
        return self._A

    @property
    def b(self) -> PETSc.Vec:  # type: ignore
        """Residual vector"""
        return self._b

    def setP(self, P: types.FunctionType, Pmat: PETSc.Mat):  # type: ignore
        """
        Set the function for computing the preconditioner matrix

        Args:
            P: Function to compute the preconditioner matrix
            Pmat: Matrix to assemble the preconditioner into

        """
        super().setP(P, Pmat)


class SNESSolver:
    def __init__(
        self,
        F: typing.Union[dolfinx.fem.Form, ufl.form.Form],
        u: typing.Union[fem.Function, list[fem.Function]],
        bcs: typing.Optional[list[fem.DirichletBC]] = None,
        J: typing.Optional[typing.Union[fem.Form, ufl.form.Form]] = None,
        P: typing.Optional[typing.Union[fem.Form, ufl.form.Form]] = None,
        mat_kind: typing.Optional[typing.Union[str, typing.Iterable[typing.Iterable[str]]]] = None,
        vec_kind: typing.Optional[str] = None,
        form_compiler_options: typing.Optional[dict] = None,
        jit_options: typing.Optional[dict] = None,
        snes_options: typing.Optional[dict] = None,
        entity_maps: typing.Optional[dict[dolfinx.mesh.Mesh, npt.NDArray[np.int32]]] = None,
    ):
        """Class for interfacing with SNES.

        Solves problems of the form :math:`F_i(u, v) = 0, i=0,...N\\ \\forall v \\in V`
        where :math:`u=(u_0,...,u_N), v=(v_0,...,v_N)` using PETSc SNES as the non-linear solver.

        Args:
            F: List of PDE residuals :math:`F_i`.
            u: List of unknowns of the block system.
            bcs: List of Dirichlet boundary conditions.
            J: Rectangular array of bi-linear forms representing the
                Jacobian :math:`J_ij = dF_i/du_j`.
            P: Rectangular array of bi-linear forms representing the preconditioner.
            mat_kind: The PETSc matrix type (``MatType``).
                See :func:`dolfinx.fem.petsc.create_matrix` for more information.
            vec_kind: The PETSc vector type (``VecType``).
                See :func:`dolfinx.fem.petsc.create_vector` for more information.
            form_compiler_options: Options used in FFCx
                compilation of this form. Run ``ffcx --help`` at the
                command line to see all available options.
            jit_options: Options used in CFFI JIT compilation of C
                code generated by FFCx. See ``python/dolfinx/jit.py``
                for all available options. Takes priority over all other
                option values.
            snes_options: Options to pass to the PETSc SNES object.
            entity_maps: If any trial functions, test functions, or
                coefficients in the form are not defined over the same mesh
                as the integration domain, ``entity_maps`` must be supplied.
                For each key (a mesh, different to the integration domain
                mesh) a map should be provided relating the entities in the
                integration domain mesh to the entities in the key mesh e.g.
                for a key-value pair ``(msh, emap)`` in ``entity_maps``,
                ``emap[i]`` is the entity in ``msh`` corresponding to entity
                ``i`` in the integration domain mesh.
        """

        self._u = u
        self._snes, self._x = create_snes_solver(
            F,
            self._u,
            bcs,
            J,
            P,
            mat_kind=mat_kind,
            vec_kind=vec_kind,
            form_compiler_options=form_compiler_options,
            jit_options=jit_options,
            entity_maps=entity_maps,
        )

        # Set PETSc options
        if snes_options is not None:
            problem_prefix = f"snes_{id(self)}"
            self._snes.setOptionsPrefix(problem_prefix)

            opts = PETSc.Options()  # type: ignore
            opts.prefixPush(problem_prefix)
            for k, v in snes_options.items():
                opts[k] = v
            self._snes.setFromOptions()
            opts.prefixPop()

            # Delete options from handler post setting
            for k in snes_options.keys():
                del opts[k]

    def solve(self) -> tuple[PETSc.Vec, int, int]:  # type: ignore
        """Solve the problem and update the solution in the problem instance.

        Returns:
            The solution, convergence reason and number of iterations
        """

        # Move current iterate into the work array.
        assign(self._u, self._x)

        # Solve problem
        self._snes.solve(None, self._x)

        # Move solution back to function
        assign(self._x, self._u)

        converged_reason = self._snes.getConvergedReason()
        return self._x, converged_reason, self._snes.getIterationNumber()

    def __del__(self):
        self._snes.destroy()
        self._x.destroy()

    @property
    def snes(self) -> PETSc.SNES:  # type: ignore
        return self._snes


def _ghostUpdate(x: PETSc.Vec, insert_mode: PETSc.InsertMode, scatter_mode: PETSc.ScatterMode):  # type: ignore
    """Helper function for ghost updating PETSc vectors"""
    try:
        for x_sub in x.getNestSubVecs():
            x_sub.ghostUpdate(addv=insert_mode, mode=scatter_mode)
    except PETSc.Error:  # type: ignore
        x.ghostUpdate(addv=insert_mode, mode=scatter_mode)


def _zero_vector(x: PETSc.Vec):  # type: ignore
    """Helper function for zeroing out PETSc vectors"""
    try:
        for x_sub in x.getNestSubVecs():
            with x_sub.localForm() as x_sub_local:
                x_sub_local.set(0.0)
    except PETSc.Error:  # type: ignore
        with x.localForm() as x_local:
            x_local.set(0.0)


def _assign_block_data(forms: typing.Iterable[dolfinx.fem.Form], vec: PETSc.Vec):
    """Assign block data to a PETSc vector.

    Args:
        forms: List of forms to extract block data from.
        vec: PETSc vector to assign block data to.
    """
    # Early exit if the vector already has block data or is a nest vector
    if vec.getAttr("_blocks") is not None or vec.getType() == "nest":
        return

    maps = [
        (
            form.function_spaces[0].dofmaps(0).index_map,
            form.function_spaces[0].dofmaps(0).index_map_bs,
        )
        for form in forms  # type: ignore
    ]
    off_owned = tuple(
        itertools.accumulate(maps, lambda off, m: off + m[0].size_local * m[1], initial=0)
    )
    off_ghost = tuple(
        itertools.accumulate(
            maps, lambda off, m: off + m[0].num_ghosts * m[1], initial=off_owned[-1]
        )
    )
    vec.setAttr("_blocks", (off_owned, off_ghost))


def assemble_residual(
    u: typing.Union[dolfinx.fem.Function, list[dolfinx.fem.Function]],
    residual: typing.Union[dolfinx.fem.Form, typing.Iterable[dolfinx.fem.Form]],
    jacobian: typing.Union[dolfinx.fem.Form, typing.Iterable[typing.Iterable[dolfinx.fem.Form]]],
    bcs: typing.Iterable[dolfinx.fem.DirichletBC],
    _snes: PETSc.SNES,  # type: ignore
    x: PETSc.Vec,  # type: ignore
    F: PETSc.Vec,  # type: ignore
):
    """Assemble the residual into the vector `F`.

    Args:
        u: Function(s) tied to the solution vector within the residual and Jacobian.
        residual: Form of the residual. It can be an list of forms.
        jacobian: Form of the Jacobian. It can be a nested list of forms.
        bcs: List of Dirichlet boundary conditions.
        _snes: The solver instance.
        x: The vector containing the point to evaluate the residual at.
        F: Vector to assemble the residual into.
    """
    # Update input vector before assigning
    _ghostUpdate(x, PETSc.InsertMode.INSERT, PETSc.ScatterMode.FORWARD)  # type: ignore

    # Assign the input vector to the unknowns
    assign(x, u)

    # Assemble the residual
    _zero_vector(F)
    try:
        # Single form and nest assembly
        assemble_vector(F, residual)
    except TypeError:
        # Block assembly
        _assign_block_data(residual, F)  # type: ignore
        assemble_vector(F, residual)  # type: ignore

    # Lift vector
    try:
        # Nest and blocked lifting
        bcs1 = _bcs_by_block(_extract_spaces(jacobian, 1), bcs)  # type: ignore
        _assign_block_data(residual, x)  # type: ignore
        apply_lifting(F, jacobian, bcs=bcs1, x0=x, alpha=-1.0)  # type: ignore
        _ghostUpdate(F, PETSc.InsertMode.ADD, PETSc.ScatterMode.REVERSE)  # type: ignore
        bcs0 = _bcs_by_block(_extract_spaces(residual), bcs)  # type: ignore
        set_bc(F, bcs0, x0=x, alpha=-1.0)
    except RuntimeError:
        # Single form lifting
        apply_lifting(F, [jacobian], bcs=[bcs], x0=[x], alpha=-1.0)  # type: ignore
        _ghostUpdate(F, PETSc.InsertMode.ADD, PETSc.ScatterMode.REVERSE)  # type: ignore
        set_bc(F, bcs, x0=x, alpha=-1.0)
    _ghostUpdate(F, PETSc.InsertMode.INSERT, PETSc.ScatterMode.FORWARD)  # type: ignore


def assemble_jacobian(
    u: typing.Union[list[fem.Function], fem.Function],
    jacobian: typing.Union[fem.Form, typing.Iterable[typing.Iterable[fem.Form]]],
    preconditioner: typing.Optional[
        typing.Union[fem.Form, typing.Iterable[typing.Iterable[fem.Form]]]
    ],
    bcs: typing.Iterable[fem.DirichletBC],
    _snes: PETSc.SNES,  # type: ignore
    x: PETSc.Vec,  # type: ignore
    J: PETSc.Mat,  # type: ignore
    P: PETSc.Mat,  # type: ignore
):
    """Assemble the Jacobian matrix and preconditioner.

    Args:
        u: Function tied to the solution vector within the residual and jacobian
        jacobian: Form of the Jacobian
        preconditioner: Form of the preconditioner
        bcs: List of Dirichlet boundary conditions
        _snes: The solver instance
        x: The vector containing the point to evaluate at
        J: Matrix to assemble the Jacobian into
        P: Matrix to assemble the preconditioner into
    """
    # Copy existing soultion into the function used in the residual and Jacobian
    try:
        x.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)  # type: ignore
    except PETSc.Error:  # type: ignore
        for x_sub in x.getNestSubVecs():
            x_sub.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)  # type: ignore
    assign(x, u)

    # Assemble Jacobian
    J.zeroEntries()
    assemble_matrix(J, jacobian, bcs, diag=1.0)  # type: ignore
    J.assemble()
    if preconditioner is not None:
        P.zeroEntries()
        assemble_matrix(P, preconditioner, bcs, diag=1.0)  # type: ignore
        P.assemble()


def create_snes_solver(
    F: typing.Union[dolfinx.fem.Form, ufl.form.Form, list[dolfinx.fem.Form], list[ufl.form.Form]],
    u: typing.Union[dolfinx.fem.Function, list[dolfinx.fem.Function]],
    bcs: typing.Optional[list[dolfinx.fem.DirichletBC]] = None,
    J: typing.Optional[
        typing.Union[
            dolfinx.fem.Form, ufl.form.Form, list[list[dolfinx.fem.Form]], list[list[ufl.Form]]
        ]
    ] = None,
    P: typing.Optional[
        typing.Union[
            dolfinx.fem.Form, ufl.form.Form, list[list[dolfinx.fem.Form]], list[list[ufl.Form]]
        ]
    ] = None,
    mat_kind: typing.Optional[typing.Union[str, typing.Iterable[typing.Iterable[str]]]] = None,
    vec_kind: typing.Optional[str] = None,
    form_compiler_options: typing.Optional[dict] = None,
    jit_options: typing.Optional[dict] = None,
    entity_maps: typing.Optional[dict[dolfinx.mesh.Mesh, npt.NDArray[np.int32]]] = None,
) -> tuple[PETSc.SNES, PETSc.Vec]:  # type: ignore
    """Create a PETSc SNES solver instance and a vector to store solutions in.

    Solves problems of the form :math:`F_i(u, v) = 0, i=0,...N\\ \\forall v \\in V`
    where :math:`u=(u_0,...,u_N), v=(v_0,...,v_N)` using PETSc SNES as the non-linear solver.

    Note:
        The user is responsible for the destruction of the returned objects.

    Args:
        F: List of PDE residuals :math:`F_i`.
        u: List of unknowns of the block system.
        bcs: List of Dirichlet boundary conditions.
        J: Rectangular array of bi-linear forms representing the
            Jacobian :math:`J_ij = dF_i/du_j`.
        P: Rectangular array of bi-linear forms representing the preconditioner.
        mat_kind: The PETSc matrix type (``MatType``).
            See :func:`dolfinx.fem.petsc.create_matrix` for more information.
        vec_kind: The PETSc vector type (``VecType``).
            See :func:`dolfinx.fem.petsc.create_vector` for more information.
        form_compiler_options: Options used in FFCx
            compilation of this form. Run ``ffcx --help`` at the
            command line to see all available options.
        jit_options: Options used in CFFI JIT compilation of C
            code generated by FFCx. See ``python/dolfinx/jit.py``
            for all available options. Takes priority over all other
            option values.
        entity_maps: If any trial functions, test functions, or
            coefficients in the form are not defined over the same mesh
            as the integration domain, ``entity_maps`` must be supplied.
            For each key (a mesh, different to the integration domain
            mesh) a map should be provided relating the entities in the
            integration domain mesh to the entities in the key mesh e.g.
            for a key-value pair ``(msh, emap)`` in ``entity_maps``,
            ``emap[i]`` is the entity in ``msh`` corresponding to entity
            ``i`` in the integration domain mesh.
    Returns:
        A PETSc SNES solver instance and a vector to store solutions in.
    """
    # Set default values if not supplied
    bcs = [] if bcs is None else bcs
    form_compiler_options = {} if form_compiler_options is None else form_compiler_options
    jit_options = {} if jit_options is None else jit_options

    # Compile residual and Jacobian forms
    residual = _create_form(
        F,
        form_compiler_options=form_compiler_options,
        jit_options=jit_options,
        entity_maps=entity_maps,
    )
    if J is None:
        J = fem.forms.compute_jacobian(F, u)
    jacobian = _create_form(
        J,
        form_compiler_options=form_compiler_options,
        jit_options=jit_options,
        entity_maps=entity_maps,
    )

    # Create PETSc structures for the residual, Jacobian and solution vector
    A = create_matrix(jacobian, kind=mat_kind)
    b = create_vector(residual, kind=vec_kind)
    x = create_vector(residual, kind=vec_kind)

    # Compile and create preconditioner structure if provided
    preconditioner = None
    P_mat = None
    if P is not None:
        preconditioner = _create_form(
            P,
            form_compiler_options=form_compiler_options,
            jit_options=jit_options,
            entity_maps=entity_maps,
        )
        P_mat = create_matrix(preconditioner, kind=mat_kind)

    # Create the SNES solver and attach the corresponding jacobian and residual
    # computation functions
    snes = PETSc.SNES().create(comm=A.comm)  # type: ignore
    snes.setJacobian(partial(assemble_jacobian, u, jacobian, preconditioner, bcs), A, P_mat)
    snes.setFunction(partial(assemble_residual, u, residual, jacobian, bcs), b)
    return snes, x
