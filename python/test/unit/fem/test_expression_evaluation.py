# Copyright (C) 2019 Michal Habera
#
# This file is part of DOLFINX (https://www.fenicsproject.org)
#
# SPDX-License-Identifier:    LGPL-3.0-or-later


import cffi
import numba
import numpy as np
from mpi4py import MPI
from petsc4py import PETSc

import ufl
import dolfinx


def test_rank0():
    """Test evaluation of UFL expression.
    This test evaluates gradient of P2 function at vertices of reference triangle.
    Because these points coincide with positions of point evaluation degrees-of-freedom
    of vector P1 space, values could be used to interpolate the expression into this space.
    This test also shows simple Numba assembler which accepts the donor P2 function ``f``
    as a coefficient and tabulates vector P1 function into tensor ``b``.
    For a donor function f(x, y) = x^2 + 2*y^2 result is compared with the exact
    gradient grad f(x, y) = [2*x, 4*y].
    """
    mesh = dolfinx.generation.UnitSquareMesh(MPI.COMM_WORLD, 5, 5)
    P2 = dolfinx.FunctionSpace(mesh, ("P", 2))
    vP1 = dolfinx.VectorFunctionSpace(mesh, ("P", 1))

    f = dolfinx.Function(P2)

    def expr1(x):
        return x[0] ** 2 + 2.0 * x[1] ** 2

    f.interpolate(expr1)

    ufl_expr = ufl.grad(f)
    points = np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]])

    compiled_expr = dolfinx.jit.ffcx_jit((ufl_expr, points))

    ffi = cffi.FFI()

    @numba.njit
    def assemble_expression(b, kernel, mesh, dofmap, coeff, coeff_dofmap):
        pos, x_dofmap, x = mesh
        geometry = np.zeros((3, 2))
        w = np.zeros(6, dtype=PETSc.ScalarType)
        constants = np.zeros(1, dtype=PETSc.ScalarType)
        b_local = np.zeros(6, dtype=PETSc.ScalarType)

        for i, cell in enumerate(pos[:-1]):
            num_vertices = pos[i + 1] - pos[i]
            c = x_dofmap[cell:cell + num_vertices]
            for j in range(3):
                for k in range(2):
                    geometry[j, k] = x[c[j], k]

            for j in range(6):
                w[j] = coeff[coeff_dofmap[i * 6 + j]]

            b_local.fill(0.0)
            kernel(ffi.from_buffer(b_local),
                   ffi.from_buffer(w),
                   ffi.from_buffer(constants),
                   ffi.from_buffer(geometry))
            for j in range(6):
                b[dofmap[i * 6 + j]] = b_local[j]

    # Prepare mesh and dofmap data
    pos = mesh.geometry.dofmap.offsets
    x_dofs = mesh.geometry.dofmap.array
    x = mesh.geometry.x
    coeff_dofmap = P2.dofmap.list.array
    dofmap = vP1.dofmap.list.array

    # Data structure for the result
    b = dolfinx.Function(vP1)

    assemble_expression(b.vector.array, compiled_expr.tabulate_expression,
                        (pos, x_dofs, x), dofmap, f.vector.array, coeff_dofmap)

    def grad_expr1(x):
        values = np.empty((2, x.shape[1]))
        values[0] = 2.0 * x[0]
        values[1] = 4.0 * x[1]

        return values

    b2 = dolfinx.Function(vP1)
    b2.interpolate(grad_expr1)

    assert np.isclose((b2.vector - b.vector).norm(), 0.0)


def test_simple_evaluation():
    """Test evaluation of UFL Expression.

    This test evaluates a UFL Expression on two cells in the mesh and compares the
    result with an analytical expression.

    For a donor function f(x, y) = (x^2 + 2*y^2) result is compared with the
    exact gradient grad f(x, y) = [2*x, 4*y]. In this test, f(x, y) is first
    interpolated into a P2 finite element space. The gradient is calculated
    using code generated by FFCX. The analytical solution is found by
    evaluating the spatial coordinates as an Expression using UFL/FFCX and
    passing the result to a numpy function that calculates the exact gradient.
    """
    mesh = dolfinx.generation.UnitSquareMesh(MPI.COMM_WORLD, 1, 1)
    P2 = dolfinx.FunctionSpace(mesh, ("P", 2))

    f = dolfinx.Function(P2)

    def exact_expr(x):
        return x[0] ** 2 + 2.0 * x[1] ** 2

    def exact_grad_expr(x):
        values = np.empty((2, x.shape[1]))
        values[0] = 2.0 * x[0]
        values[1] = 4.0 * x[1]

        return values

    f.interpolate(exact_expr)

    ufl_grad_expr = ufl.grad(f)
    points = np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]])
    grad_expr = dolfinx.Expression(ufl_grad_expr, points)
    assert grad_expr.num_points == 3
    assert grad_expr.value_size == 2

    cells = np.array([0, 1], dtype=np.int32)
    grad_expr_evaluated = grad_expr.eval(cells)

    # Evaluate points in global space
    ufl_x = ufl.SpatialCoordinate(mesh)
    x_expr = dolfinx.Expression(ufl_x, points)
    assert x_expr.num_points == 3
    assert x_expr.value_size == 2
    x_evaluated = x_expr.eval(cells)

    # NOTE: Will need to be adjusted when new XYZXYZ ordering is introduced?
    x_global = np.zeros((2, cells.shape[0] * x_expr.num_points))
    # Have to reshape to use standard expression code
    x_global[0, :] = x_evaluated[:, 0:3].flatten()
    x_global[1, :] = x_evaluated[:, 3:].flatten()
    # Evaluate exact gradient using global points
    grad_expr_exact = exact_grad_expr(x_evaluated)
    grad_expr_exact_reshape = np.empty_like(grad_expr_exact)
    # And reshape back to match output of Expression.
    grad_expr_exact_reshape[0, :] = grad_expr_exact[:, 0:3].flatten()
    grad_expr_exact_reshape[1, :] = grad_expr_exact[:, 3:].flatten()

    expected_result = np.array([[0, 2, 2, 0, 0, 4], [0, 0, 2, 0, 4, 4]], dtype=np.float64)
    assert(np.allclose(grad_expr_evaluated, expected_result))
    assert(np.allclose(grad_expr_evaluated, grad_expr_exact_reshape))
